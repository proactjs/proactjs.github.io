<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: actor.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: actor.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>
 *  Constructs a ProAct.Actor. It can be used both as observer and observable.
 * &lt;/p>
 * &lt;p>
 *  The actors in ProAct.js form the dependency graph.
 *  If some actor listens to changes from another - it depends on it.
 * &lt;/p>
 * &lt;p>
 *  The actors can transform the values or events incoming to them.
 * &lt;/p>
 * &lt;p>
 *  Every actor can have a parent actor, that will be notified for all the changes
 *  on the child-actor, it is something as special observer.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Actor is part of the core module of ProAct.js.
 * &lt;/p>
 *
 * @class ProAct.Actor
 * @param {String} queueName
 *      The name of the queue all the updates should be pushed to.
 *      &lt;p>
 *        If this parameter is null/undefined the default queue of
 *        {@link ProAct.flow} is used.
 *      &lt;/p>
 *      &lt;p>
 *        If this parameter is not a string it is used as the
 *        &lt;i>transforms&lt;/i>.
 *      &lt;/p>
 * @param {Array} transforms
 *      A list of transformation to be used on all incoming chages.
 */
function Actor (queueName, transforms) {
  if (queueName && !P.U.isString(queueName)) {
    transforms = queueName;
    queueName = null;
  }

  P.U.defValProp(this, 'listeners', false, false, true, this.defaultListeners());

  P.U.defValProp(this, 'listener', false, false, true, null);
  P.U.defValProp(this, 'errListener', false, false, true, null);
  P.U.defValProp(this, 'closeListener', false, false, true, null);
  P.U.defValProp(this, 'parent', false, false, true, null);

  P.U.defValProp(this, 'queueName', false, false, false, queueName);
  P.U.defValProp(this, 'transforms', false, false, true,
                 (transforms ? transforms : []));

  P.U.defValProp(this, 'state', false, false, true, P.States.init);

  this.init();
}
ProAct.Actor = P.Pro = Actor;

P.U.ex(P.Actor, {

  /**
   * A constant defining bad values or bad events.
   *
   * @memberof ProAct.Actor
   * @type Object
   * @static
   * @constant
   */
  BadValue: {},

  /**
   * A constant defining closing or ending events.
   *
   * @memberof ProAct.Actor
   * @type Object
   * @static
   * @constant
   */
  Close: {},

  /**
   * Transforms the passed &lt;i>val&lt;/i> using the ProAct.Actor#transforms of the passed &lt;i>actor&lt;/i>.
   *
   * @function transforms
   * @memberof ProAct.Actor
   * @static
   * @param {ProAct.Actor} actor
   *      The ProAct.Actor which transformations should be used.
   * @param {Object} val
   *      The value to transform.
   * @return {Object}
   *      The transformed value.
   */
  transform: function (actor, val) {
    var i, t = actor.transforms, ln = t.length;
    for (i = 0; i &lt; ln; i++) {
      val = t[i].call(actor, val);
      if (val === P.Actor.BadValue) {
        break;
      }
    }

    return val;
  }
});

P.Actor.prototype = {

  /**
   * Reference to the constructor of this object.
   *
   * @memberof ProAct.Actor
   * @instance
   * @constant
   * @default ProAct.Actor
   */
  constructor: ProAct.Actor,

  /**
   * Initializes this actor.
   * &lt;p>
   *  This method logic is run only if the current state of &lt;i>this&lt;/i> is {@link ProAct.States.init}.
   * &lt;/p>
   * &lt;p>
   *  Then {@link ProAct.Actor#afterInit} is called to finish the initialization.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method init
   * @see {@link ProAct.Actor#doInit}
   * @see {@link ProAct.Actor#afterInit}
   */
  init: function () {
    if (this.state !== P.States.init) {
      return;
    }

    this.doInit();

    this.afterInit();
  },

  /**
   * Allocating of resources or initializing is done here.
   * &lt;p>
   *  Empty by default.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method doInit
   * @see {@link ProAct.Actor#init}
   */
  doInit: function () {},

  /**
   * Called automatically after initialization of this actor.
   * &lt;p>
   *  By default it changes the state of &lt;i>this&lt;/i> to {@link ProAct.States.ready}.
   * &lt;/p>
   * &lt;p>
   *  It can be overridden to define more complex initialization logic.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method afterInit
   */
  afterInit: function () {
    this.state = P.States.ready;
  },

  /**
   * Called immediately before destruction.
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method beforeDestroy
   * @see {@link ProAct.Actor#destroy}
   */
  beforeDestroy: function () {
  },

  /**
   * Frees additional resources.
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method doDestroy
   * @see {@link ProAct.Actor#destroy}
   */
  doDestroy: function () {
  },

  /**
   * Destroys this ProAct.Actor instance.
   * &lt;p>
   *  The state of &lt;i>this&lt;/i> is set to {@link ProAct.States.destroyed}.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method destroy
   */
  destroy: function () {
    if (this.state === P.States.destroyed) {
      return;
    }

    this.beforeDestroy();
    this.doDestroy();

    this.listeners = undefined;

    if (this.listener) {
      this.listener.destroyed = true;
    }
    this.listener = undefined;
    this.errListener = undefined;
    this.closeListener = undefined;
    this.parent = undefined;

    this.queueName = undefined;
    this.transforms = undefined;

    this.state = P.States.destroyed;
  },

  /**
   * Checks if &lt;i>this&lt;/i> can be dstroyed.
   * &lt;p>
   *  Defaults to return true.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method canDestroy
   */
  canDestroy: function () {
    return true;
  },

  /**
   * Generates the initial listeners object. It can be overridden for alternative listeners collections.
   * It is used for resetting all the listeners too.
   *
   * @memberof ProAct.Actor
   * @instance
   * @method defaultListeners
   * @return {Object}
   *      A map containing the default listeners collections.
   */
  defaultListeners: function () {
    return {
      change: [],
      error: [],
      close: []
    };
  },

  /**
   * A list of actions or action to be used when no action is passed for the methods working with actions.
   *
   * @memberof ProAct.Actor
   * @instance
   * @method defaultActions
   * @default 'change'
   * @return {Array|String}
   *      The actions to be used if no actions are provided to action related methods,
   *      like {@link ProAct.Actor#on}, {@link ProAct.Actor#off}, {@link ProAct.Actor#update}, {@link ProAct.Actor#willUpdate}.
   */
  defaultActions: function () {
    return 'change';
  },

  /**
   * Creates the &lt;i>listener&lt;/i> of this actor.
   * Every actor should have one listener that should pass to other actors.
   * &lt;p>
   *  This listener turns the actor in a observer.
   * &lt;/p>
   * &lt;p>
   *  Should be overriden with specific listener, by default it returns null.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method makeListener
   * @default null
   * @return {Object}
   *      The &lt;i>listener of this observer&lt;/i>.
   */
  makeListener: P.N,

  /**
   * Creates the &lt;i>error listener&lt;/i> of this actor.
   * Every actor should have one error listener that should pass to other actors.
   * &lt;p>
   *  This listener turns the actor in a observer for errors.
   * &lt;/p>
   * &lt;p>
   *  Should be overriden with specific listener, by default it returns null.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method makeErrListener
   * @default null
   * @return {Object}
   *      The &lt;i>error listener of this observer&lt;/i>.
   */
  makeErrListener: P.N,

  /**
   * Creates the &lt;i>closing listener&lt;/i> of this actor.
   * Every actor should have one closing listener that should pass to other actors.
   * &lt;p>
   *  This listener turns the actor in a observer for closing events.
   * &lt;/p>
   * &lt;p>
   *  Should be overriden with specific listener, by default it returns null.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method makeCloseListener
   * @default null
   * @return {Object}
   *      The &lt;i>closing listener of this observer&lt;/i>.
   */
  makeCloseListener: P.N,

  /**
   * Creates the &lt;i>event&lt;/i> to be send to the listeners on update.
   * &lt;p>
   *  The &lt;i>event&lt;/i> should be an instance of {@link ProAct.Event}.
   * &lt;/p>
   * &lt;p>
   *  By default this method returns {@link ProAct.Event.Types.value} event.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method makeEvent
   * @default {ProAct.Event} with type {@link ProAct.Event.Types.value}
   * @param {ProAct.Event} source
   *      The source event of the event. It can be null
   * @return {ProAct.Event}
   *      The event.
   */
  makeEvent: function (source) {
    return new P.Event(source, this, P.Event.Types.value);
  },

  /**
   * Attaches a new listener to this ProAct.Actor.
   * The listener may be function or object that defines a &lt;i>call&lt;/i> method.
   *
   * @memberof ProAct.Actor
   * @instance
   * @method on
   * @param {Array|String} actions
   *      The action/actions to listen for. If this parameter is skipped or null/undefined, the actions from {@link ProAct.Actor#defaultActions} are used.
   *      &lt;p>
   *        The actions can be skipped and on their place as first parameter to be passed the &lt;i>listener&lt;/i>.
   *      &lt;/p>
   * @param {Object} listener
   *      The listener to attach. It must be instance of Function or object with a &lt;i>call&lt;/i> method.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#defaultActions}
   */
  on: function (actions, listener) {
    if (!P.U.isString(actions) && !P.U.isArray(actions)) {
      listener = actions;
      actions = this.defaultActions();
    }
    if (!P.U.isArray(actions)) {
      actions = [actions];
    }

    var ln = actions.length,
        action, i, listeners;

    for (i = 0; i &lt; ln; i ++) {
      action = actions[i];
      listeners = this.listeners[action];

      if (!listeners) {
        listeners = this.listeners[action] = [];
      }

      listeners.push(listener);
    }

    return this;
  },

  /**
   * Removes a &lt;i>listener&lt;/i> from the passed &lt;i>action&lt;/i>.
   * &lt;p>
   *  If this method is called without parameters, all the listeners for all the actions are removed.
   *  The listeners are reset using {@link ProAct.Actor#defaultListeners}.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method off
   * @param {Array|String} actions
   *      The action/actions to stop listening for. If this parameter is skipped or null/undefined, the actions from {@link ProAct.Actor#defaultActions} are used.
   *      &lt;p>
   *        The actions can be skipped and on their place as first parameter to be passed the &lt;i>listener&lt;/i>.
   *      &lt;/p>
   * @param {Object} listener
   *      The listener to detach. If it is skipped, null or undefined all the listeners are removed from this actor.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#on}
   * @see {@link ProAct.Actor#defaultActions}
   * @see {@link ProAct.Actor#defaultListeners}
   */
  off: function (actions, listener) {
    if (!actions && !listener) {
      this.listeners = this.defaultListeners();
      return this;
    }

    if (!P.U.isString(actions) && !P.U.isArray(actions)) {
      listener = actions;
      actions = this.defaultActions();
    }
    if (!P.U.isArray(actions)) {
      actions = [actions];
    }

    var ln = actions.length,
        action, i, listeners;

    for (i = 0; i &lt; ln; i ++) {
      action = actions[i];
      listeners = this.listeners[action];

      if (listeners) {
        P.U.remove(listeners, listener);
      }
    }

    return this;
  },

  /**
   * Attaches a new error listener to this ProAct.Actor.
   * The listener may be function or object that defines a &lt;i>call&lt;/i> method.
   *
   * @memberof ProAct.Actor
   * @instance
   * @method onErr
   * @param {Object} listener
   *      The listener to attach. It must be instance of Function or object with a &lt;i>call&lt;/i> method.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#on}
   */
  onErr: function (listener) {
    return this.on('error', listener);
  },

  /**
   * Removes an error &lt;i>listener&lt;/i> from the passed &lt;i>action&lt;/i>.
   *
   * @memberof ProAct.Actor
   * @instance
   * @method offErr
   * @param {Object} listener
   *      The listener to detach. If it is skipped, null or undefined all the listeners are removed from this actor.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#onErr}
   */
  offErr: function (listener) {
    return this.off('error', listener);
  },

  onClose: function (listener) {
    return this.on('close', listener);
  },

  offClose: function (listener) {
    return this.off('close', listener);
  },

  /**
   * Links source actors into this actor. This means that &lt;i>this actor&lt;/i>
   * is listening for changes from the &lt;i>sources&lt;/i>.
   * &lt;p>
   *  A good example is one stream to have another as as source -> if data comes into the source
   *  stream, it is passed to the listening too. That way the source stream is plugged &lt;b>into&lt;/b> the listening one.
   * &lt;/p>
   * &lt;p>
   *  The listeners from {@link ProAct.Actor#makeListener} and {@link ProAct.Actor#makeErrListener} are used.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method into
   * @param [...]
   *      Zero or more source ProAct.Actors to set as sources.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#makeListener}
   * @see {@link ProAct.Actor#makeErrListener}
   */
  into: function () {
    var args = slice.call(arguments),
        ln = args.length, i, source;
    for (i = 0; i &lt; ln; i++) {
      source = args[i];
      source.on(this.makeListener());
      source.onErr(this.makeErrListener());
      source.onClose(this.makeCloseListener());
    }

    return this;
  },

  /**
   * The reverse of {@link ProAct.Actor#into} - sets &lt;i>this actor&lt;/i> as a source
   * to the passed &lt;i>destination&lt;/i> actor.
   *
   * @memberof ProAct.Actor
   * @instance
   * @method out
   * @param {ProAct.Actor} destination
   *      The actor to set as source &lt;i>this&lt;/i> to.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#into}
   */
  out: function (destination) {
    destination.into(this);

    return this;
  },

  /**
   * Adds a new &lt;i>transformation&lt;/i> to the list of transformations
   * of &lt;i>this actor&lt;/i>.
   * &lt;p>
   *  A transformation is a function or an object that has a &lt;i>call&lt;/i> method defined.
   *  This function or call method should have one argument and to return a transformed version of it.
   *  If the returned value is {@link ProAct.Actor.BadValue}, the next transformations are skipped and the updating
   *  value/event becomes - bad value.
   * &lt;/p>
   * &lt;p>
   *  Every value/event that updates &lt;i>this actor&lt;/i> will be transformed using the new transformation.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method transform
   * @param {Object} transformation
   *      The transformation to add.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor.transform}
   */
  transform: function (transformation) {
    this.transforms.push(transformation);
    return this;
  },

  /**
   * Adds a mapping transformation to &lt;i>this actor&lt;/i>.
   * &lt;p>
   *  Mapping transformations just transform one value into another. For example if we get update with
   *  the value of &lt;i>3&lt;/i> and we have mapping transformation that returns the updating value powered by &lt;i>2&lt;/i>,
   *  we'll get &lt;i>9&lt;/i> as actual updating value.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method mapping
   * @param {Object} mappingFunction
   *      Function or object with a &lt;i>call method&lt;/i> to use as map function.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#transform}
   */
  mapping: function (mappingFunction) {
    return this.transform(mappingFunction)
  },

  /**
   * Adds a filtering transformation to &lt;i>this actor&lt;/i>.
   * &lt;p>
   *  Filtering can be used to filter the incoming update values. For example you can
   *  filter by only odd numbers as update values.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method filtering
   * @param {Object} filteringFunction
   *      The filtering function or object with a call method, should return boolean.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#transform}
   */
  filtering: function(filteringFunction) {
    var _this = this;
    return this.transform(function (val) {
      if (filteringFunction.call(_this, val)) {
        return val;
      }
      return P.Actor.BadValue;
    });
  },

  /**
   * Adds an accumulation transformation to &lt;i>this actor&lt;/i>.
   * &lt;p>
   *  Accumulation is used to compute a value based on the previous one.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method accumulation
   * @param {Object} initVal
   *      Initial value for the accumulation. For example '0' for sum.
   * @param {Object} accumulationFunction
   *      The function to accumulate.
   * @return {ProAct.Actor}
   *      &lt;b>this&lt;/b>
   * @see {@link ProAct.Actor#transform}
   */
  accumulation: function (initVal, accumulationFunction) {
    var _this = this, val = initVal;
    return this.transform(function (newVal) {
      val = accumulationFunction.call(_this, val, newVal)
      return val;
    });
  },

  /**
   * Creates a new ProAct.Actor instance with source &lt;i>this&lt;/i> and mapping
   * the passed &lt;i>mapping function&lt;/i>.
   * &lt;p>
   *  Should be overridden with creating the right actor.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method map
   * @param {Object} mappingFunction
   *      Function or object with a &lt;i>call method&lt;/i> to use as map function.
   * @return {ProAct.Actor}
   *      A new ProAct.Actor instance with the &lt;i>mapping&lt;/i> applied.
   * @see {@link ProAct.Actor#mapping}
   */
  map: P.N,

  /**
   * Creates a new ProAct.Actor instance with source &lt;i>this&lt;/i> and filtering
   * the passed &lt;i>filtering function&lt;/i>.
   * &lt;p>
   *  Should be overridden with creating the right actor.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method filter
   * @param {Object} filteringFunction
   *      The filtering function or object with a call method, should return boolean.
   * @return {ProAct.Actor}
   *      A new ProAct.Actor instance with the &lt;i>filtering&lt;/i> applied.
   * @see {@link ProAct.Actor#filtering}
   */
  filter: P.N,

  /**
   * Creates a new ProAct.Actor instance with source &lt;i>this&lt;/i> and accumulation
   * the passed &lt;i>accumulation function&lt;/i>.
   * &lt;p>
   *  Should be overridden with creating the right actor.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @abstract
   * @method accumulate
   * @param {Object} initVal
   *      Initial value for the accumulation. For example '0' for sum.
   * @param {Object} accumulationFunction
   *      The function to accumulate.
   * @return {ProAct.Actor}
   *      A new ProAct.Actor instance with the &lt;i>accumulation&lt;/i> applied.
   * @see {@link ProAct.Actor#accumulation}
   */
  accumulate: P.N,

  /**
   * Generates a new {@link ProAct.Val} containing the state of an accumulations.
   * &lt;p>
   *  The value will be updated with every update coming to this actor.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method reduce
   * @param {Object} initVal
   *      Initial value for the accumulation. For example '0' for sum.
   * @param {Object} accumulationFunction
   *      The function to accumulate.
   * @return {ProAct.Val}
   *      A {@link ProAct.Val} instance observing &lt;i>this&lt;/i> with the accumulation applied.
   * @see {@link ProAct.Actor#accumulate}
   * @see {@link ProAct.Val}
   */
  reduce: function (initVal, accumulationFunction) {
    return new P.Val(initVal).into(this.accumulate(initVal, accumulationFunction));
  },

  /**
   * Update notifies all the observers of this ProAct.Actor.
   * &lt;p>
   *  If there is running {@link ProAct.flow} instance it uses it to call the
   *  {@link ProAct.Actor.willUpdate} action with the passed &lt;i>parameters&lt;/i>.
   * &lt;/p>
   * &lt;p>
   *  If {@link ProAct.flow} is not running, a new instance is created and the
   *  {@link ProAct.Actor.willUpdate} action of &lt;i>this&lt;/i> is called in it.
   * &lt;/p>
   *
   * TODO Should be 'triggerActions'
   *
   * @memberof ProAct.Actor
   * @instance
   * @method update
   * @param {Object} source
   *      The source of the update, for example update of ProAct.Actor, that &lt;i>this&lt;/i> is observing.
   *      &lt;p>
   *        Can be null - no source.
   *      &lt;/p>
   *      &lt;p>
   *        In the most cases {@link ProAct.Event} is the source.
   *      &lt;/p>
   * @param {Array|String} actions
   *      A list of actions or a single action to update the listeners that listen to it.
   * @param {Array} eventData
   *      Data to be passed to the event to be created.
   * @return {ProAct.Actor}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Actor#willUpdate}
   * @see {@link ProAct.Actor#makeEvent}
   * @see {@link ProAct.flow}
   */
  update: function (source, actions, eventData) {
    if (this.state === ProAct.States.destroyed) {
      throw new Error('You can not trigger actions on destroyed actors!');
    }

    var actor = this;
    if (!P.flow.isRunning()) {
      P.flow.run(function () {
        actor.willUpdate(source, actions, eventData);
      });
    } else {
      actor.willUpdate(source, actions, eventData);
    }
    return this;
  },

  /**
   * &lt;b>willUpdate()&lt;/b> is the method used to notify observers that &lt;i>this&lt;/i> ProAct.Actor will be updated.
   * &lt;p>
   *  It uses the {@link ProAct.Actor#defer} to defer the listeners of the listening ProAct.Actors.
   *  The idea is that everything should be executed in a running {@link ProAct.Flow}, so there will be no repetative
   *  updates.
   * &lt;/p>
   * &lt;p>
   *  The update value will come from the {@link ProAct.Actor#makeEvent} method and the &lt;i>source&lt;/i>
   *  parameter will be passed to it.
   * &lt;/p>
   * &lt;p>
   *  If &lt;i>this&lt;/i> ProAct.Actor has a &lt;i>parent&lt;/i> ProAct.Actor it will be notified in the running flow
   *  as well.
   * &lt;/p>
   *
   * TODO Should be 'update'
   *
   * @memberof ProAct.Actor
   * @instance
   * @method willUpdate
   * @param {Object} source
   *      The source of the update, for example update of ProAct.Actor, that &lt;i>this&lt;/i> is observing.
   *      &lt;p>
   *        Can be null - no source.
   *      &lt;/p>
   *      &lt;p>
   *        In the most cases {@link ProAct.Event} is the source.
   *      &lt;/p>
   * @param {Array|String} actions
   *      A list of actions or a single action to update the listeners that listen to it.
   *      If there is no action provided, the actions from {@link ProAct.Actor#defaultActions} are used.
   * @param {Array} eventData
   *      Data to be passed to the event to be created.
   * @return {ProAct.Actor}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Actor#defer}
   * @see {@link ProAct.Actor#makeEvent}
   * @see {@link ProAct.Actor#defaultActions}
   * @see {@link ProAct.flow}
   */
  willUpdate: function (source, actions, eventData) {
    if (!actions) {
      actions = this.defaultActions();
    }

    var ln, i, j,
        listener,
        listeners,
        length,
        event;

    if (P.U.isString(actions)) {
      listeners = this.listeners[actions];
    } else {
      while (actions.indexOf('close') !== -1) {
        P.U.remove(actions, 'close');
      }

      listeners = [];
      ln = actions.length;

      if (this.parent === null && actions.length === 0) {
        return this;
      }

      for (i = 0; i &lt; ln; i++) {
        listenersForAction = this.listeners[actions[i]];

        if (listenersForAction) {
          for (j = 0; j &lt; listenersForAction.length; j++) {
            if (listenersForAction[j].destroyed) {
              this.off(actions[i], listenersForAction[j]);
              continue;
            }
          }
          listeners = listeners.concat(listenersForAction);
        }
      }
    }

    if (listeners.length === 0 && this.parent === null && actions !== 'close') {
      return this;
    }

    if (actions === 'close' && !this.canDestroy()) {
      return this;
    }

    length = listeners.length;
    event = this.makeEvent(source, eventData);

    for (i = 0; i &lt; length; i++) {
      listener = listeners[i];
      if (P.U.isString(actions) && listener.destroyed) {
        this.off(actions, listener);
        continue;
      }

      this.defer(event, listener);

      if (listener.property) {
        listener.property.willUpdate(event);
      }
    }

    if (this.parent && this.parent.call) {
      this.defer(event, this.parent);
    }

    if (actions === 'close') {
      P.flow.pushClose(this, this.destroy);
    }

    return this;
  },

  /**
   * Defers a ProAct.Actor listener.
   * &lt;p>
   *  By default this means that the listener is put into active {@link ProAct.Flow} using it's
   *  {@link ProAct.Flow#pushOnce} method, but it can be overridden.
   * &lt;/p>
   *
   * @memberof ProAct.Actor
   * @instance
   * @method defer
   * @param {Object} event
   *      The event/value to pass to the listener.
   * @param {Object} listener
   *      The listener to defer. It should be a function or object defining the &lt;i>call&lt;/i> method.
   * @return {ProAct.Actor}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Actor#willUpdate}
   * @see {@link ProAct.Actor#makeListener}
   * @see {@link ProAct.flow}
   */
  defer: function (event, listener) {
    var queueName = (listener.queueName) ? listener.queueName : this.queueName;

    if (P.U.isFunction(listener)) {
      P.flow.pushOnce(queueName, listener, [event]);
    } else {
      P.flow.pushOnce(queueName, listener, listener.call, [event]);
    }
    return this;
  },
};

/**
 * &lt;p>
 *  Constructs a ProAct.Observable. It can be used both as observer and actor.
 * &lt;/p>
 * &lt;p>
 *  The observables in ProAct.js form the dependency graph.
 *  If some observable listens to changes from another - it depends on it.
 * &lt;/p>
 * &lt;p>
 *  The observables can transform the values or events incoming to them.
 * &lt;/p>
 * &lt;p>
 *  Every observable can have a parent observable, that will be notified for all the changes
 *  on the child-observable, it is something as special observer.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Observable is part of the core module of ProAct.js.
 * &lt;/p>
 *
 * @class ProAct.Observable
 * @param {Array} transforms
 *      A list of transformation to be used on all incoming chages.
 * @deprecated since version 1.1.1. Use {@link ProAct.Actor} instead.
 * @see {@link ProAct.Actor}
 */
ProAct.Observable = ProAct.Actor;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Actor.html">Actor</a></li><li><a href="ProAct.Array.html">Array</a></li><li><a href="ProAct.ArrayCore.html">ArrayCore</a></li><li><a href="ProAct.ArrayProperty.html">ArrayProperty</a></li><li><a href="ProAct.ArrayPropertyProvider.html">ArrayPropertyProvider</a></li><li><a href="ProAct.AutoProperty.html">AutoProperty</a></li><li><a href="ProAct.AutoPropertyProvider.html">AutoPropertyProvider</a></li><li><a href="ProAct.BufferedStream.html">BufferedStream</a></li><li><a href="ProAct.Core.html">Core</a></li><li><a href="ProAct.DebouncingStream.html">DebouncingStream</a></li><li><a href="ProAct.DelayedStream.html">DelayedStream</a></li><li><a href="ProAct.Event.html">Event</a></li><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.NullProperty.html">NullProperty</a></li><li><a href="ProAct.NullPropertyProvider.html">NullPropertyProvider</a></li><li><a href="ProAct.ObjectCore.html">ObjectCore</a></li><li><a href="ProAct.ObjectProperty.html">ObjectProperty</a></li><li><a href="ProAct.ObjectPropertyProvider.html">ObjectPropertyProvider</a></li><li><a href="ProAct.Observable.html">Observable</a></li><li><a href="ProAct.Property.html">Property</a></li><li><a href="ProAct.PropertyProvider.html">PropertyProvider</a></li><li><a href="ProAct.ProxyProperty.html">ProxyProperty</a></li><li><a href="ProAct.ProxyPropertyProvider.html">ProxyPropertyProvider</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li><li><a href="ProAct.Registry.html">Registry</a></li><li><a href="ProAct.Registry.FunctionProvider.html">FunctionProvider</a></li><li><a href="ProAct.Registry.ProObjectProvider.html">ProObjectProvider</a></li><li><a href="ProAct.Registry.Provider.html">Provider</a></li><li><a href="ProAct.Registry.StreamProvider.html">StreamProvider</a></li><li><a href="ProAct.SimplePropertyProvider.html">SimplePropertyProvider</a></li><li><a href="ProAct.SizeBufferedStream.html">SizeBufferedStream</a></li><li><a href="ProAct.Stream.html">Stream</a></li><li><a href="ProAct.ThrottlingStream.html">ThrottlingStream</a></li><li><a href="ProAct.Val.html">Val</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Array.Listeners.html">Listeners</a></li><li><a href="ProAct.Array.Operations.html">Operations</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.DSL.html">DSL</a></li><li><a href="ProAct.DSL.ops.html">ops</a></li><li><a href="ProAct.DSL.predefined.html">predefined</a></li><li><a href="ProAct.DSL.predefined.accumulation.html">accumulation</a></li><li><a href="ProAct.DSL.predefined.filtering.html">filtering</a></li><li><a href="ProAct.DSL.predefined.mapping.html">mapping</a></li><li><a href="ProAct.Event.Types.html">Types</a></li><li><a href="ProAct.OpStore.html">OpStore</a></li><li><a href="ProAct.Property.Types.html">Types</a></li><li><a href="ProAct.Registry.ProObjectProvider.types.html">types</a></li><li><a href="ProAct.Registry.Provider.types.html">types</a></li><li><a href="ProAct.Registry.StreamProvider.types.html">types</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Mon Nov 03 2014 09:40:31 GMT+0200 (EET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
