<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/js/arrays/listeners.js - proact.js</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
	    <img alt="proact.js" src="https://proactjs.github.io/proact_logo_small.png" style="max-height: 65%;" title="proact.js">
        
            proact.js
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.3.1</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/ProAct", "classes/ProAct.Actor", "classes/ProAct.ActorUtil", "classes/ProAct.Array", "classes/ProAct.Array.Listeners", "classes/ProAct.Array.Operations", "classes/ProAct.ArrayCore", "classes/ProAct.ArrayProperty", "classes/ProAct.ArrayPropertyProvider", "classes/ProAct.ArrayUtils", "classes/ProAct.AutoProperty", "classes/ProAct.AutoPropertyProvider", "classes/ProAct.BufferedStream", "classes/ProAct.Configuration", "classes/ProAct.Core", "classes/ProAct.DebouncingStream", "classes/ProAct.DelayedStream", "classes/ProAct.DSL", "classes/ProAct.DSL.ops", "classes/ProAct.DSL.predefined", "classes/ProAct.DSL.predefined.accumulation", "classes/ProAct.DSL.predefined.filtering", "classes/ProAct.DSL.predefined.mapping", "classes/ProAct.Event", "classes/ProAct.Event.Types", "classes/ProAct.Flow", "classes/ProAct.ObjectCore", "classes/ProAct.ObjectProperty", "classes/ProAct.ObjectPropertyProvider", "classes/ProAct.OpStore", "classes/ProAct.OpStore.all", "classes/ProAct.ProbProvider", "classes/ProAct.Property", "classes/ProAct.Property.Types", "classes/ProAct.PropertyProvider", "classes/ProAct.ProxyProperty", "classes/ProAct.ProxyPropertyProvider", "classes/ProAct.Queue", "classes/ProAct.Queues", "classes/ProAct.Registry", "classes/ProAct.Registry.FunctionProvider", "classes/ProAct.Registry.ProObjectProvider", "classes/ProAct.Registry.ProObjectProvider.types", "classes/ProAct.Registry.Provider", "classes/ProAct.Registry.Provider.types", "classes/ProAct.Registry.StreamProvider", "classes/ProAct.Registry.StreamProvider.types", "classes/ProAct.SimplePropertyProvider", "classes/ProAct.SizeBufferedStream", "classes/ProAct.States", "classes/ProAct.Stream", "classes/ProAct.SubscribableStream", "classes/ProAct.ThrottlingStream", "classes/ProAct.Utils", "classes/ProAct.ValueEvent", "modules/proact-arrays", "modules/proact-core", "modules/proact-dsl", "modules/proact-flow", "modules/proact-properties", "modules/proact-streams"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <h3>APIs</h3>
    <div id="sidebar">
        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
            <li><a href="#modules" data-toggle="tab">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" placeholder="Type to filter APIs">
        </div>

        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
            <div class="tab-pane active" id="classes">
                <ul id="api-classes" class="nav nav-list">
                    
                        <li><a href="../classes/ProAct.html">ProAct</a></li>
                    
                        <li><a href="../classes/ProAct.Actor.html">ProAct.Actor</a></li>
                    
                        <li><a href="../classes/ProAct.Array.html">ProAct.Array</a></li>
                    
                        <li><a href="../classes/ProAct.Array.Listeners.html">ProAct.Array.Listeners</a></li>
                    
                        <li><a href="../classes/ProAct.Array.Operations.html">ProAct.Array.Operations</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayCore.html">ProAct.ArrayCore</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayProperty.html">ProAct.ArrayProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayPropertyProvider.html">ProAct.ArrayPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayUtils.html">ProAct.ArrayUtils</a></li>
                    
                        <li><a href="../classes/ProAct.AutoProperty.html">ProAct.AutoProperty</a></li>
                    
                        <li><a href="../classes/ProAct.AutoPropertyProvider.html">ProAct.AutoPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.BufferedStream.html">ProAct.BufferedStream</a></li>
                    
                        <li><a href="../classes/ProAct.Configuration.html">ProAct.Configuration</a></li>
                    
                        <li><a href="../classes/ProAct.Core.html">ProAct.Core</a></li>
                    
                        <li><a href="../classes/ProAct.DebouncingStream.html">ProAct.DebouncingStream</a></li>
                    
                        <li><a href="../classes/ProAct.DelayedStream.html">ProAct.DelayedStream</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.html">ProAct.DSL</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.ops.html">ProAct.DSL.ops</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.html">ProAct.DSL.predefined</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.accumulation.html">ProAct.DSL.predefined.accumulation</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.filtering.html">ProAct.DSL.predefined.filtering</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.mapping.html">ProAct.DSL.predefined.mapping</a></li>
                    
                        <li><a href="../classes/ProAct.Event.html">ProAct.Event</a></li>
                    
                        <li><a href="../classes/ProAct.Event.Types.html">ProAct.Event.Types</a></li>
                    
                        <li><a href="../classes/ProAct.Flow.html">ProAct.Flow</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectCore.html">ProAct.ObjectCore</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectProperty.html">ProAct.ObjectProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectPropertyProvider.html">ProAct.ObjectPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.OpStore.html">ProAct.OpStore</a></li>
                    
                        <li><a href="../classes/ProAct.OpStore.all.html">ProAct.OpStore.all</a></li>
                    
                        <li><a href="../classes/ProAct.ProbProvider.html">ProAct.ProbProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Property.html">ProAct.Property</a></li>
                    
                        <li><a href="../classes/ProAct.Property.Types.html">ProAct.Property.Types</a></li>
                    
                        <li><a href="../classes/ProAct.PropertyProvider.html">ProAct.PropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.ProxyProperty.html">ProAct.ProxyProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ProxyPropertyProvider.html">ProAct.ProxyPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Queue.html">ProAct.Queue</a></li>
                    
                        <li><a href="../classes/ProAct.Queues.html">ProAct.Queues</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.html">ProAct.Registry</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.FunctionProvider.html">ProAct.Registry.FunctionProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.ProObjectProvider.html">ProAct.Registry.ProObjectProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.ProObjectProvider.types.html">ProAct.Registry.ProObjectProvider.types</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.Provider.html">ProAct.Registry.Provider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.Provider.types.html">ProAct.Registry.Provider.types</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.StreamProvider.html">ProAct.Registry.StreamProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.StreamProvider.types.html">ProAct.Registry.StreamProvider.types</a></li>
                    
                        <li><a href="../classes/ProAct.SimplePropertyProvider.html">ProAct.SimplePropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.SizeBufferedStream.html">ProAct.SizeBufferedStream</a></li>
                    
                        <li><a href="../classes/ProAct.States.html">ProAct.States</a></li>
                    
                        <li><a href="../classes/ProAct.Stream.html">ProAct.Stream</a></li>
                    
                        <li><a href="../classes/ProAct.SubscribableStream.html">ProAct.SubscribableStream</a></li>
                    
                        <li><a href="../classes/ProAct.ThrottlingStream.html">ProAct.ThrottlingStream</a></li>
                    
                        <li><a href="../classes/ProAct.Utils.html">ProAct.Utils</a></li>
                    
                        <li><a href="../classes/ProAct.ValueEvent.html">ProAct.ValueEvent</a></li>
                    
                </ul>
            </div>

            <div class="tab-pane" id="modules">
                <ul id="api-modules" class="nav nav-list">
                    
                        <li><a href="../modules/proact-arrays.html">proact-arrays</a></li>
                    
                        <li><a href="../modules/proact-core.html">proact-core</a></li>
                    
                        <li><a href="../modules/proact-dsl.html">proact-dsl</a></li>
                    
                        <li><a href="../modules/proact-flow.html">proact-flow</a></li>
                    
                        <li><a href="../modules/proact-properties.html">proact-properties</a></li>
                    
                        <li><a href="../modules/proact-streams.html">proact-streams</a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>src/js/arrays/listeners.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * @module proact-arrays
 */

/**
 * Defines a set of special listeners used to trak {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} changes and updating dependent {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}s in an optimal way.
 *
 * @class Listeners
 * @namespace ProAct.Array
 * @static
 */
ProAct.Array.Listeners = P.A.L = pArrayLs = {

  /**
   * Checks the validity of an event.
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Event} event
   *      The event to check.
   * @throws {Error}
   *      If the event is not {{#crossLink &quot;ProAct.Event.Types/array:property&quot;}}{{/crossLink}}
   */
  check: function(event) {
    if (event.type !== P.E.Types.array) {
      throw Error(&#x27;Not implemented for non array events&#x27;);
    }
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} method is another {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; one.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var b = a.concat(7, 9); // b is [1, 3, 5, 7, 9]
   *  &lt;/pre&gt;
   *  The new array - &lt;b&gt;b&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we push something to &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;b&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.push(11); // b authomatically should become [1, 3, 5, 11, 7, 9]
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;transformed&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Array} transformed
   *      The array created as a result of invoking {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;transformed&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  leftConcat: function (transformed, original, args) {
    return function (event) {
      pArrayLs.check(event);
      var op    = event.args[0],
          ind   = event.args[1],
          ov    = event.args[2],
          nv    = event.args[3],
          argln = args.length,
          nvs, toAdd;
      if (op === pArrayOps.set) {
        transformed[ind] = nv;
      } else if (op === pArrayOps.add) {
        nvs = slice.call(nv, 0);
        if (ind === 0) {
          pArrayProto.unshift.apply(transformed, nvs);
        } else {
          pArrayProto.splice.apply(transformed, [transformed._array.length - argln, 0].concat(nvs));
        }
      } else if (op === pArrayOps.remove) {
        if (ind === 0) {
          pArrayProto.shift.call(transformed, ov);
        } else {
          pArrayProto.splice.apply(transformed, [transformed._array.length - argln - 1, 1]);
        }
      } else if (op === pArrayOps.setLength) {
        nvs = ov -nv;
        if (nvs &gt; 0) {
          pArrayProto.splice.apply(transformed, [nv, nvs]);
        } else {
          toAdd = [ov, 0];
          toAdd.length = 2 - nvs;
          pArrayProto.splice.apply(transformed, toAdd);
        }
      } else if (op === pArrayOps.reverse || op === pArrayOps.sort) {
        nvs = transformed._array;
        if (P.AU.isProArray(args)) {
          toAdd = args._array;
        } else {
          toAdd = args;
        }
        transformed._array.length = 0;
        push.apply(transformed._array, concat.apply(original._array, toAdd));
        transformed.core.updateByDiff(nvs);
      } else if (op === pArrayOps.splice) {
        pArrayProto.splice.apply(transformed, [ind, ov.length].concat(nv));
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} is invoked with argument, another {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} method is another {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}},
   *  dependent on both the &lt;i&gt;original&lt;/i&gt; and the passed as an argument one.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var x = new ProAct.Array(7, 9);
   *    var b = a.concat(x); // b is [1, 3, 5, 7, 9]
   *  &lt;/pre&gt;
   *  The new array - &lt;b&gt;b&lt;/b&gt; is dependent on &lt;b&gt;x&lt;/b&gt;, so if for example we push something to &lt;b&gt;x&lt;/b&gt;, &lt;b&gt;b&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    x.push(13); // b authomatically should become [1, 3, 5, 7, 9, 13]
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;transformed&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Array} transformed
   *      The array created as a result of invoking {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}} was invoked.
   * @param {ProAct.Array} right
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} passed as an argument to {{#crossLink &quot;ProAct.Array/concat:method&quot;}}{{/crossLink}}.
   * @return {Function}
   *      A listener for events from the &lt;i&gt;right&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;transformed&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  rightConcat: function (transformed, original, right) {
    return function (event) {
      pArrayLs.check(event);
      var op    = event.args[0],
          ind   = event.args[1],
          ov    = event.args[2],
          nv    = event.args[3],
          oln   = original._array.length,
          nvs;
      if (op === pArrayOps.set) {
        transformed[oln + ind] = nv;
      } else if (op === pArrayOps.add) {
        if (ind === 0) {
          pArrayProto.splice.apply(transformed, [oln, 0].concat(nv));
        } else {
          pArrayProto.push.apply(transformed, nv);
        }
      } else if (op === pArrayOps.remove) {
        if (ind === 0) {
          pArrayProto.splice.call(transformed, oln, 1);
        } else {
          pArrayProto.pop.call(transformed, ov);
        }
      } else if (op === pArrayOps.setLength) {
        transformed.length = oln + nv;
      } else if (op === pArrayOps.reverse || op === pArrayOps.sort) {
        nvs = transformed._array;
        transformed._array.length = 0;
        push.apply(transformed._array, concat.apply(original._array, right._array));
        transformed.core.updateByDiff(nvs);
      } else if (op === pArrayOps.splice) {
        pArrayProto.splice.apply(transformed, [ind + oln, ov.length].concat(nv));
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/pevery:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/pevery:method&quot;}}{{/crossLink}} method is a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; array.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/pevery:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var val = a.pevery(function (el) {
   *      return el % 2 === 1;
   *    }); // val.v is true.
   *  &lt;/pre&gt;
   *  The new value - &lt;b&gt;val&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we push something to &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;val&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.push(2); // val.v authomatically should become false.
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; array changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Property} val
   *      The result of invoking {{#crossLink &quot;ProAct.Array/pevery:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/pevery:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/pevery:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  every: function (val, original, args) {
    var fun = args[0], thisArg = args[1];
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          ev;
      if (op === pArrayOps.set) {
        ev = fun.call(thisArg, nv);
        if (val.valueOf() === true &amp;&amp; !ev) {
          val.v = false;
        } else if (val.valueOf() === false &amp;&amp; ev) {
          val.v = every.apply(original._array, args);
        }
      } else if (op === pArrayOps.add) {
        if (val.valueOf() === true) {
          val.v = every.call(nv, fun, thisArg);
        }
      } else if (op === pArrayOps.remove) {
        if (val.valueOf() === false &amp;&amp; !fun.call(thisArg, ov)) {
          val.v = every.apply(original._array, args);
        }
      } else if (op === pArrayOps.setLength) {
        if (val.valueOf() === false) {
          val.v = every.apply(original._array, args);
        }
      } else if (op === pArrayOps.splice) {
        if (val.valueOf() === true) {
          val.v = every.call(nv, fun, thisArg);
        } else if (every.call(nv, fun, thisArg) &amp;&amp; !every.call(ov, fun, thisArg)) {
          val.v = every.apply(original._array, args);
        }
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/psome:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/psome:method&quot;}}{{/crossLink}} method is a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; array.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/psome:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var val = a.psome(function (el) {
   *      return el % 2 === 0;
   *    }); // val.v is false.
   *  &lt;/pre&gt;
   *  The new value - &lt;b&gt;val&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we push something to &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;val&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.push(2); // val.v authomatically should become true
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; array changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Property} val
   *      The result of invoking {{#crossLink &quot;ProAct.Array/psome:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/psome:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/psome:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  some: function (val, original, args) {
    var fun = args[0], thisArg = args[1];
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          sv;
      if (op === pArrayOps.set) {
        sv = fun.call(thisArg, nv);
        if (val.valueOf() === false &amp;&amp; sv) {
          val.v = true;
        } else if (val.valueOf() === true &amp;&amp; !sv) {
          val.v = some.apply(original._array, args);
        }
      } else if (op === pArrayOps.add) {
        if (val.valueOf() === false) {
          val.v = some.call(nv, fun, thisArg);
        }
      } else if (op === pArrayOps.remove) {
        if (val.valueOf() === true &amp;&amp; fun.call(thisArg, ov)) {
          val.v = some.apply(original._array, args);
        }
      } else if (op === pArrayOps.setLength) {
        if (val.valueOf() === true) {
          val.v = some.apply(original._array, args);
        }
      } else if (op === pArrayOps.splice) {
        if (val.valueOf() === false) {
          val.v = some.call(nv, fun, thisArg);
        } else if (some.call(ov, fun, thisArg) &amp;&amp; !some.call(nv, fun, thisArg)) {
          val.v = some.apply(original._array, args);
        }
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/filter:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/filter:method&quot;}}{{/crossLink}} method is another {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; one.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/filter:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var b = a.filter(function (el) {
   *      return el % 2 === 0;
   *    }); // b is []
   *  &lt;/pre&gt;
   *  The new array - &lt;b&gt;b&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we unshift something to &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;b&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.unshift(4); // b authomatically should become [4]
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;filtered&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Array} filtered
   *      The array created as a result of invoking {{#crossLink &quot;ProAct.Array/filter:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/filter:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/filter:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;filtered&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  filter: function (filtered, original, args) {
    var fun = args[0], thisArg = args[1];
    return function (event) {
      if (P.U.isFunction(event)) {
        args[0] = fun = event;
        pArray.reFilter(original, filtered, args);
        return;
      }

      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          napply, oapply, oarr,
          nvs, fnvs, j, ln, diff;

      if (op === pArrayOps.set) {
        napply = fun.call(thisArg, nv);
        oapply = fun.call(thisArg, ov);

        if (oapply === true || napply === true) {
          pArray.reFilter(original, filtered, args);
        }
      } else if (op === pArrayOps.add) {
        fnvs = [];
        nvs = slice.call(nv, 0);
        ln = nvs.length;
        if (ind === 0) {
          j = ln - 1;
          while(j &gt;= 0) {
            if (fun.apply(thisArg, [nvs[j], j, original._array])) {
              fnvs.unshift(nvs[j]);
            }
            j--;
          }

          if (fnvs.length) {
            pArrayProto.unshift.apply(filtered, fnvs);
          }
        } else {
          j = 0;
          while(j &lt; ln) {
            if (fun.apply(thisArg, [nvs[j], original._array.length - (ln - j), original._array])) {
              fnvs.push(nvs[j]);
            }
            j++;
          }

          if (fnvs.length) {
            pArrayProto.push.apply(filtered, fnvs);
          }
        }
      } else if (op === pArrayOps.remove) {
        if (fun.apply(thisArg, [ov, ind, original._array])) {
          if (ind === 0) {
            filtered.shift();
          } else {
            filtered.pop();
          }
        }
      } else if (op === pArrayOps.setLength) {
        pArray.reFilter(original, filtered, args);
      } else if (op === pArrayOps.reverse) {
        filtered.reverse();
      } else if (op === pArrayOps.sort) {
        pArrayProto.sort.apply(filtered, nv);
      } else if (op === pArrayOps.splice) {
        pArray.reFilter(original, filtered, args);
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/map:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/map:method&quot;}}{{/crossLink}} method is another {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; one.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/map:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var b = a.map(function (el) {
   *      return el * el;
   *    }); // b is [1, 9, 25]
   *  &lt;/pre&gt;
   *  The new array - &lt;b&gt;b&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we pop from &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;b&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.pop(); // b authomatically should become [1, 9]
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;mapped&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Array} mapped
   *      The array created as a result of invoking {{#crossLink &quot;ProAct.Array/map:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/map:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/map:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;mapped&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  map: function (mapped, original, args) {
    var fun = args[0], thisArg = args[1];
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          nvs, j, ln, mnvs;
      if (op === pArrayOps.set) {
        mapped[ind] = fun.call(thisArg, nv);
      } else if (op === pArrayOps.add) {
        mnvs = [];
        nvs = slice.call(nv, 0);
        ln = nvs.length;
        if (ind === 0) {
          j = ln - 1;
          while(j &gt;= 0) {
            mnvs[j] = fun.apply(thisArg, [nvs[j], j, original._array]);
            j--;
          }

          pArrayProto.unshift.apply(mapped, mnvs);
        } else {
          j = 0;
          while(j &lt; ln) {
            mnvs[j] = fun.apply(thisArg, [nvs[j], original._array.length - (ln - j), original._array]);
            j++;
          }

          pArrayProto.push.apply(mapped, mnvs);
        }
      } else if (op === pArrayOps.remove) {
        if (ind === 0) {
          mapped.shift();
        } else {
          mapped.pop();
        }
      } else if (op === pArrayOps.setLength) {
        mapped.length = nv;
      } else if (op === pArrayOps.reverse) {
        mapped.reverse();
      } else if (op === pArrayOps.sort) {
        pArrayProto.sort.apply(mapped, nv);
      } else if (op === pArrayOps.splice) {
        mnvs = [];
        j = 0;
        while (j &lt; nv.length) {
          mnvs[j] = fun.apply(thisArg, [nv[j], (j + ind), original._array]);
          j++;
        }

        pArrayProto.splice.apply(mapped, [
          ind,
          ov.length
        ].concat(mnvs));
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/preduce:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/preduce:method&quot;}}{{/crossLink}} method is a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; array.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/preduce:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var val = a.preduce(function (pel, el) {
   *      return pel + el;
   *    }, 0); // val.v is 0 + 1 + 3 + 5 = 9.
   *  &lt;/pre&gt;
   *  The new value - &lt;b&gt;val&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we shift from &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;val&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.shift(); // val.v authomatically should become 0 + 3 + 5 = 8.
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; array changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Property} val
   *      The result of invoking {{#crossLink &quot;ProAct.Array/preduce:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/preduce:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/preduce:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  reduce: function (val, original, args) {
    var oldLn = original._array.length, fun = args[0];
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3];
      if ((op === pArrayOps.add &amp;&amp; ind !== 0) ||
         (op === pArrayOps.splice &amp;&amp; ind &gt;= oldLn &amp;&amp; ov.length === 0)) {
        val.v = reduce.apply(nv, [fun, val.valueOf()]);
      } else {
        val.v = reduce.apply(original._array, args);
      }
      oldLn = original._array.length;
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/preduceRight:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/preduceRight:method&quot;}}{{/crossLink}} method is a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; array.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/preduceRight:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var val = a.preduceRight(function (pel, el) {
   *      return pel + el;
   *    }, 0); // val.v is 0 + 5 + 3 + 1 = 9.
   *  &lt;/pre&gt;
   *  The new value - &lt;b&gt;val&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we splice &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;val&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.splice(1, 2, 4, 5); // val.v authomatically should become 0 + 5 + 4 + 1 = 10.
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; array changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Property} val
   *      The result of invoking {{#crossLink &quot;ProAct.Array/preduceRight:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/preduceRight:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/preduceRight:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  reduceRight: function (val, original, args) {
    var fun = args[0];
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3];
      if ((op === pArrayOps.add &amp;&amp; ind === 0) ||
         (op === pArrayOps.splice &amp;&amp; ind === 0 &amp;&amp; ov.length === 0)) {
        val.v = reduceRight.apply(nv, [fun, val.valueOf()]);
      } else {
        val.v = reduceRight.apply(original._array, args);
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/pindexOf:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/pindexOf:method&quot;}}{{/crossLink}} method is a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; array.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/pindexOf:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var val = a.pindexOf(5); // val.v is 2.
   *  &lt;/pre&gt;
   *  The new value - &lt;b&gt;val&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we reverse &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;val&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.reverse(); // val.v authomatically should become 0.
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; array changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Property} val
   *      The result of invoking {{#crossLink &quot;ProAct.Array/pindexOf:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/pindexOf:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/pindexOf:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  indexOf: function (val, original, args) {
    var what = args[0], fromIndex = args[1], hasFrom = !!fromIndex;
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          v = val.valueOf(),
          nvi, i;

      if (op === pArrayOps.set) {
        if (ov === what) {
          val.v = indexOf.apply(original._array, args);
        } else if (nv === what &amp;&amp; (ind &lt; v || v === -1) &amp;&amp; (!hasFrom || ind &gt;= fromIndex)) {
          val.v = ind;
        }
      } else if (op === pArrayOps.add) {
        nvi = nv.indexOf(what);
        if (ind === 0) {
          if (nvi !== -1 &amp;&amp; (!hasFrom || ind &gt;= fromIndex)) {
            val.v = nvi;
          } else if (v !== -1) {
            val.v = v + nv.length;
          }
        } else if (v === -1 &amp;&amp;  (!hasFrom || ind &gt;= fromIndex)) {
          if (nvi !== -1) {
            val.v = ind;
          }
        }
      } else if (op === pArrayOps.remove) {
        if (v !== -1) {
          if (ind === 0) {
            if (ov === what &amp;&amp; !hasFrom) {
              val.v = indexOf.apply(original._array, args);
            } else {
              val.v = v - 1;
            }
          } else if (what === ov) {
            val.v = -1;
          }
        }
      } else if (op === pArrayOps.setLength &amp;&amp; nv &lt;= v) {
        val.v = -1;
      } else if (op === pArrayOps.reverse || op === pArrayOps.sort) {
        val.v = indexOf.apply(original._array, args);
      } else if (op === pArrayOps.splice) {
        nvi = nv.indexOf(what);
        i = nvi + ind;
        if (ind &lt;= v) {
          if (nvi !== -1 &amp;&amp; i &lt; v &amp;&amp; (!hasFrom || fromIndex &lt;= i)) {
            val.v = i;
          } else if (nv.length !== ov.length &amp;&amp; ov.indexOf(what) === -1) {
            v = v + (nv.length - ov.length);
            if (!hasFrom || v &gt;= fromIndex) {
              val.v = v;
            } else {
              val.v = indexOf.apply(original._array, args);
            }
          } else {
            val.v = indexOf.apply(original._array, args);
          }
        } else if (v === -1 &amp;&amp; nvi !== -1) {
          val.v = i;
        }
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/plastIndexOf:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/plastIndexOf:method&quot;}}{{/crossLink}} method is a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; array.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([5, 4, 5, 3]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/plastIndexOf:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var val = a.plastIndexOf(5); // val.v is 2.
   *  &lt;/pre&gt;
   *  The new value - &lt;b&gt;val&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we sort &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;val&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.sort(); // val.v authomatically should become 3.
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; array changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Property} val
   *      The result of invoking {{#crossLink &quot;ProAct.Array/plastIndexOf:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/plastIndexOf:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/plastIndexOf:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;val&lt;/i&gt; {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  lastIndexOf: function (val, original, args) {
    var what = args[0], fromIndex = args[1], hasFrom = !!fromIndex;
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          v = val.valueOf(),
          nvi, i;

      if (op === pArrayOps.set) {
        if (ov === what) {
          val.v = lastIndexOf.apply(original._array, args);
        } else if (nv === what &amp;&amp; (ind &gt; v || v === -1) &amp;&amp; (!hasFrom || ind &lt;= fromIndex)) {
          val.v = ind;
        }
      } else if (op === pArrayOps.add) {
        nvi = nv.indexOf(what);
        if (ind === 0) {
          if (nvi !== -1 &amp;&amp; v === -1 &amp;&amp; (!hasFrom || ind &lt;= fromIndex)) {
            val.v = nvi;
          } else if (v !== -1) {
            val.v = v + nv.length;
          }
        } else if (nvi !== -1 &amp;&amp; (!hasFrom || (ind + nvi) &lt;= fromIndex)) {
          val.v = ind + nvi;
        }
      } else if (op === pArrayOps.remove) {
        if (v !== -1) {
          if (ind === 0) {
            val.v = v - 1;
          } else if (what === ov) {
            val.v = lastIndexOf.apply(original._array, args);
          }
        }
      } else if (op === pArrayOps.splice || op === pArrayOps.reverse || op === pArrayOps.sort || (op === pArrayOps.setLength &amp;&amp; nv &lt; ov)) {
        val.v = lastIndexOf.apply(original._array, args);
      }
    };
  },

  /**
   * Generates a listener that can be attached to an {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which
   * the method {{#crossLink &quot;ProAct.Array/slice:method&quot;}}{{/crossLink}} is invoked.
   * &lt;p&gt;
   *  The result of the {{#crossLink &quot;ProAct.Array/slice:method&quot;}}{{/crossLink}} method is another {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, dependent on the &lt;i&gt;original&lt;/i&gt; one.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  For example if the original was:
   *  &lt;pre&gt;
   *    var a = new ProAct.Array([1, 3, 5]);
   *  &lt;/pre&gt;
   *  and we invoked {{#crossLink &quot;ProAct.Array/slice:method&quot;}}{{/crossLink}} on it like this:
   *  &lt;pre&gt;
   *    var b = a.slice(1); // b is [3, 5]
   *  &lt;/pre&gt;
   *  The new array - &lt;b&gt;b&lt;/b&gt; is dependent on &lt;b&gt;a&lt;/b&gt;, so if for example we push to &lt;b&gt;a&lt;/b&gt;, &lt;b&gt;b&lt;/b&gt; should be updated:
   *  &lt;pre&gt;
   *    a.push(32); // b authomatically should become [3, 5, 32]
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The generated listener by this method does this - updates the &lt;i&gt;sliced&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, when the &lt;i&gt;original&lt;/i&gt; changes
   *  and it does it in an optimal way.
   * &lt;/p&gt;
   *
   * @for ProAct.Array.Listeners
   * @static
   * @param {ProAct.Array} sliced
   *      The array created as a result of invoking {{#crossLink &quot;ProAct.Array/slice:method&quot;}}{{/crossLink}} on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}.
   * @param {ProAct.Array} original
   *      The {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on which {{#crossLink &quot;ProAct.Array/slice:method&quot;}}{{/crossLink}} was invoked.
   * @param {Array} args
   *      The arguments passed to {{#crossLink &quot;ProAct.Array/slice:method&quot;}}{{/crossLink}}, when it was invoked on the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}
   * @return {Function}
   *      A listener for events from the &lt;i&gt;original&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}}, updating the &lt;i&gt;sliced&lt;/i&gt; {{#crossLink &quot;ProAct.Array&quot;}}{{/crossLink}} on
   *      every new event, if it is necessary.
   */
  slice: function (sliced, original, args) {
    var s = args[0], e = args[1], hasEnd = !!e;
    return function (event) {
      pArrayLs.check(event);
      var op  = event.args[0],
          ind = event.args[1],
          ov  = event.args[2],
          nv  = event.args[3],
          osl;
      if (op === pArrayOps.set) {
        if (ind &gt;= s &amp;&amp; (!hasEnd || ind &lt; e)) {
          sliced[ind - s] = nv;
        }
      } else {
        osl = sliced._array;
        sliced._array.length = 0;
        push.apply(sliced._array, slice.apply(original._array, args));
        sliced.core.updateByDiff(osl);
      }
    };
  }
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
