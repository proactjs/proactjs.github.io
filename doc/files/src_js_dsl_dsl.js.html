<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/js/dsl/dsl.js - proact.js</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
	    <img alt="proact.js" src="https://proactjs.github.io/proact_logo_small.png" style="max-height: 65%;" title="proact.js">
        
            proact.js
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.3.1</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/ProAct", "classes/ProAct.Actor", "classes/ProAct.ActorUtil", "classes/ProAct.Array", "classes/ProAct.Array.Listeners", "classes/ProAct.Array.Operations", "classes/ProAct.ArrayCore", "classes/ProAct.ArrayProperty", "classes/ProAct.ArrayPropertyProvider", "classes/ProAct.ArrayUtils", "classes/ProAct.AutoProperty", "classes/ProAct.AutoPropertyProvider", "classes/ProAct.BufferedStream", "classes/ProAct.Configuration", "classes/ProAct.Core", "classes/ProAct.DebouncingStream", "classes/ProAct.DelayedStream", "classes/ProAct.DSL", "classes/ProAct.DSL.ops", "classes/ProAct.DSL.predefined", "classes/ProAct.DSL.predefined.accumulation", "classes/ProAct.DSL.predefined.filtering", "classes/ProAct.DSL.predefined.mapping", "classes/ProAct.Event", "classes/ProAct.Event.Types", "classes/ProAct.Flow", "classes/ProAct.ObjectCore", "classes/ProAct.ObjectProperty", "classes/ProAct.ObjectPropertyProvider", "classes/ProAct.OpStore", "classes/ProAct.OpStore.all", "classes/ProAct.ProbProvider", "classes/ProAct.Property", "classes/ProAct.Property.Types", "classes/ProAct.PropertyProvider", "classes/ProAct.ProxyProperty", "classes/ProAct.ProxyPropertyProvider", "classes/ProAct.Queue", "classes/ProAct.Queues", "classes/ProAct.Registry", "classes/ProAct.Registry.FunctionProvider", "classes/ProAct.Registry.ProObjectProvider", "classes/ProAct.Registry.ProObjectProvider.types", "classes/ProAct.Registry.Provider", "classes/ProAct.Registry.Provider.types", "classes/ProAct.Registry.StreamProvider", "classes/ProAct.Registry.StreamProvider.types", "classes/ProAct.SimplePropertyProvider", "classes/ProAct.SizeBufferedStream", "classes/ProAct.States", "classes/ProAct.Stream", "classes/ProAct.SubscribableStream", "classes/ProAct.ThrottlingStream", "classes/ProAct.Utils", "classes/ProAct.ValueEvent", "modules/proact-arrays", "modules/proact-core", "modules/proact-dsl", "modules/proact-flow", "modules/proact-properties", "modules/proact-streams"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <h3>APIs</h3>
    <div id="sidebar">
        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
            <li><a href="#modules" data-toggle="tab">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" placeholder="Type to filter APIs">
        </div>

        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
            <div class="tab-pane active" id="classes">
                <ul id="api-classes" class="nav nav-list">
                    
                        <li><a href="../classes/ProAct.html">ProAct</a></li>
                    
                        <li><a href="../classes/ProAct.Actor.html">ProAct.Actor</a></li>
                    
                        <li><a href="../classes/ProAct.Array.html">ProAct.Array</a></li>
                    
                        <li><a href="../classes/ProAct.Array.Listeners.html">ProAct.Array.Listeners</a></li>
                    
                        <li><a href="../classes/ProAct.Array.Operations.html">ProAct.Array.Operations</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayCore.html">ProAct.ArrayCore</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayProperty.html">ProAct.ArrayProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayPropertyProvider.html">ProAct.ArrayPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayUtils.html">ProAct.ArrayUtils</a></li>
                    
                        <li><a href="../classes/ProAct.AutoProperty.html">ProAct.AutoProperty</a></li>
                    
                        <li><a href="../classes/ProAct.AutoPropertyProvider.html">ProAct.AutoPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.BufferedStream.html">ProAct.BufferedStream</a></li>
                    
                        <li><a href="../classes/ProAct.Configuration.html">ProAct.Configuration</a></li>
                    
                        <li><a href="../classes/ProAct.Core.html">ProAct.Core</a></li>
                    
                        <li><a href="../classes/ProAct.DebouncingStream.html">ProAct.DebouncingStream</a></li>
                    
                        <li><a href="../classes/ProAct.DelayedStream.html">ProAct.DelayedStream</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.html">ProAct.DSL</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.ops.html">ProAct.DSL.ops</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.html">ProAct.DSL.predefined</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.accumulation.html">ProAct.DSL.predefined.accumulation</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.filtering.html">ProAct.DSL.predefined.filtering</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.mapping.html">ProAct.DSL.predefined.mapping</a></li>
                    
                        <li><a href="../classes/ProAct.Event.html">ProAct.Event</a></li>
                    
                        <li><a href="../classes/ProAct.Event.Types.html">ProAct.Event.Types</a></li>
                    
                        <li><a href="../classes/ProAct.Flow.html">ProAct.Flow</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectCore.html">ProAct.ObjectCore</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectProperty.html">ProAct.ObjectProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectPropertyProvider.html">ProAct.ObjectPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.OpStore.html">ProAct.OpStore</a></li>
                    
                        <li><a href="../classes/ProAct.OpStore.all.html">ProAct.OpStore.all</a></li>
                    
                        <li><a href="../classes/ProAct.ProbProvider.html">ProAct.ProbProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Property.html">ProAct.Property</a></li>
                    
                        <li><a href="../classes/ProAct.Property.Types.html">ProAct.Property.Types</a></li>
                    
                        <li><a href="../classes/ProAct.PropertyProvider.html">ProAct.PropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.ProxyProperty.html">ProAct.ProxyProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ProxyPropertyProvider.html">ProAct.ProxyPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Queue.html">ProAct.Queue</a></li>
                    
                        <li><a href="../classes/ProAct.Queues.html">ProAct.Queues</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.html">ProAct.Registry</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.FunctionProvider.html">ProAct.Registry.FunctionProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.ProObjectProvider.html">ProAct.Registry.ProObjectProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.ProObjectProvider.types.html">ProAct.Registry.ProObjectProvider.types</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.Provider.html">ProAct.Registry.Provider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.Provider.types.html">ProAct.Registry.Provider.types</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.StreamProvider.html">ProAct.Registry.StreamProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.StreamProvider.types.html">ProAct.Registry.StreamProvider.types</a></li>
                    
                        <li><a href="../classes/ProAct.SimplePropertyProvider.html">ProAct.SimplePropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.SizeBufferedStream.html">ProAct.SizeBufferedStream</a></li>
                    
                        <li><a href="../classes/ProAct.States.html">ProAct.States</a></li>
                    
                        <li><a href="../classes/ProAct.Stream.html">ProAct.Stream</a></li>
                    
                        <li><a href="../classes/ProAct.SubscribableStream.html">ProAct.SubscribableStream</a></li>
                    
                        <li><a href="../classes/ProAct.ThrottlingStream.html">ProAct.ThrottlingStream</a></li>
                    
                        <li><a href="../classes/ProAct.Utils.html">ProAct.Utils</a></li>
                    
                        <li><a href="../classes/ProAct.ValueEvent.html">ProAct.ValueEvent</a></li>
                    
                </ul>
            </div>

            <div class="tab-pane" id="modules">
                <ul id="api-modules" class="nav nav-list">
                    
                        <li><a href="../modules/proact-arrays.html">proact-arrays</a></li>
                    
                        <li><a href="../modules/proact-core.html">proact-core</a></li>
                    
                        <li><a href="../modules/proact-dsl.html">proact-dsl</a></li>
                    
                        <li><a href="../modules/proact-flow.html">proact-flow</a></li>
                    
                        <li><a href="../modules/proact-properties.html">proact-properties</a></li>
                    
                        <li><a href="../modules/proact-streams.html">proact-streams</a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>src/js/dsl/dsl.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * @module proact-dsl
 */

/**
 * Contains {{#crossLink &quot;ProAct.DSL&quot;}}{{/crossLink}} operation logic definitions.
 * &lt;p&gt;
 *  Every operation has
 *  &lt;ol&gt;
 *    &lt;li&gt;&lt;b&gt;sym&lt;/b&gt; - A symbol used to identify the right operation in a DSL string or object.&lt;/li&gt;
 *    &lt;li&gt;&lt;b&gt;match method&lt;/b&gt; - A method used for identifying the operation, usually it uses the &lt;i&gt;sym&lt;/i&gt;&lt;/li&gt;
 *    &lt;li&gt;
 *      &lt;b&gt;toOptions&lt;/b&gt; - A method which is able to turn a DSL string with the operation,
 *      into an actual array of options containing all the functions to be executed by the DSL and their arguments.
 *    &lt;/li&gt;
 *    &lt;li&gt;&lt;b&gt;action&lt;/b&gt; - The operation logic. The options object of the above method should be passed to it, as well as the targed on which the DSL should be run.&lt;/li&gt;
 *  &lt;/ol&gt;
 * &lt;/p&gt;
 *
 * @namespace ProAct
 * @class OpStore
 * @static
 */
ProAct.OpStore = {

  all: {

    /**
     * Can generate a simple operation definition.
     * &lt;p&gt;
     *  It is used for defining all the simple operations, like &lt;i&gt;map&lt;/i&gt; or &lt;i&gt;filter&lt;/i&gt;.
     * &lt;/p&gt;
     *
     * @for ProAct.OpStore.all
     * @static
     * @param {String} name
     *      The name of the operation to define.
     * @param {String} sym
     *      The symbol of the operation that shoul dbe used to identify it from within a DSL string.
     * @return {Object}
     *      &lt;ol&gt;
     *        &lt;li&gt;&lt;b&gt;sym&lt;/b&gt; - The symbol used to identify the operation in a DSL string or object.&lt;/li&gt;
     *        &lt;li&gt;&lt;b&gt;match method&lt;/b&gt; - A method using the &lt;i&gt;sym&lt;/i&gt; for identifying the operation in a DSL string.&lt;/li&gt;
     *        &lt;li&gt;
     *          &lt;b&gt;toOptions&lt;/b&gt; - A method which is able to turn a DSL string with the operation,
     *          into the actual array of options containing all the functions to be executed by the DSL and their arguments.
     *          &lt;p&gt;
     *            This method is able to fetch predefined operation functions.
     *          &lt;/p&gt;
     *        &lt;/li&gt;
     *        &lt;li&gt;
     *          &lt;b&gt;action&lt;/b&gt; - The operation logic.
     *          The options object of the above method should be passed to it, as well as the targed on which the DSL should be run.
     *          &lt;p&gt;
     *            It just calls method named as the passed &lt;i&gt;name&lt;/i&gt; parameter on the targed &lt;i&gt;object&lt;/i&gt;, passing it as arguments,
     *            the argument array generated from the &lt;i&gt;toOptions&lt;/i&gt; method.
     *          &lt;/p&gt;
     *        &lt;/li&gt;
     *      &lt;/ol&gt;
     */
    simpleOp: function(name, sym) {
      return {
        sym: sym,
        match: function (op) {
          return op.substring(0, sym.length) === sym;
        },
        setupArgument: function (arg, realArguments, predefined, opArguments) {
          var i, k, ln, actions;
          if (arg.charAt(0) === &#x27;$&#x27;) {
            arg = realArguments[parseInt(arg.substring(1), 10) - 1];
          } else if (predefined &amp;&amp; arg.charAt(0) === &#x27;&amp;&#x27;) {
            i = arg.lastIndexOf(&#x27;&amp;&#x27;);
            k = arg.substring(0, i);
            if (predefined[k]) {
              arg = predefined[k].call(null, arg.substring(i + 1));
            }
          } else if (predefined &amp;&amp; arg.charAt(0) === &#x27;!&#x27;) {
            arg = this.setupArgument(arg.substring(1), realArguments, predefined, opArguments);
            if (arg) {
              k = arg;
              arg = function () {
                return !k.apply(null, arguments);
              };
            }
          } else if (predefined &amp;&amp; predefined[arg]) {
            arg = predefined[arg];

            if (P.U.isArray(arg)) {
              opArguments.push.apply(opArguments, arg);
              arg = undefined;
            }
          }

          return arg;
        },
        toOptions: function (actionObject, op) {
          var reg = new RegExp(dslOps[name].sym + &quot;(\\w*)\\(([\\s\\S]*)\\)&quot;),
              matched = reg.exec(op),
              action = matched[1], args = matched[2],
              opArguments = [],
              realArguments = slice.call(arguments, 2),
              predefined = dsl.predefined[name],
              arg, i , ln, k;
          if (action) {
            opArguments.push(action);
          }

          if (args) {
            args = args.split(&#x27;,&#x27;);
            ln = args.length;
            for (i = 0; i &lt; ln; i++) {
              arg = args[i].trim();
              arg = this.setupArgument(arg, realArguments, predefined, opArguments);

              if (arg !== undefined) {
                opArguments.push(arg);
              }
            }
          }

          if (!actionObject[name]) {
            actionObject[name] = opArguments;
          } else {
            if (!P.U.isArray(actionObject[name][0])) {
              actionObject[name] = [actionObject[name], opArguments];
            } else {
              actionObject[name].push(opArguments);
            }
          }

          actionObject.order = actionObject.order || [];
          actionObject.order.push(name);
        },
        action: function (object, actionObject) {
          if (!actionObject || !actionObject[name]) {
            return object;
          }

          var args = actionObject[name];
          if (!P.U.isArray(args)) {
            args = [args];
          }

          if (name === &#x27;accumulation&#x27; &amp;&amp; P.U.isArray(args[0]) &amp;&amp; args[0].length == 2 &amp;&amp; P.U.isFunction(args[0][1])) {
            args = args[0];
          }

          return object[name].apply(object, args);
        }
      };
    }
  }
};
opStoreAll = P.OpStore.all;

/**
 * Contains implementation of the &#x60;ProAct.js DSL&#x60;.
 * &lt;p&gt;
 *  The idea of the DSL is to define {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}}s and their dependencies on each other in a declarative and simple way.
 * &lt;/p&gt;
 * &lt;p&gt;
 *  The {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} is used to store these actors.
 * &lt;/p&gt;
 * &lt;p&gt;
 *  For example if we want to have a stream configured to write in a property, it is very easy done using the DSL:
 *  &lt;pre&gt;
 *    ProAct.registry.prob(&#x27;val&#x27;, 0, &#x27;&lt;&lt;(s:data)&#x27;);
 *  &lt;/pre&gt;
 *  This tells the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} to create a {{#crossLink &quot;ProAct.Property&quot;}}{{/crossLink}} with the value of zero, and to point the previously,
 *  stored &#x27;data&#x27; stream to it.
 * &lt;/p&gt;
 *
 * @namespace ProAct
 * @class DSL
 * @static
 */
ProAct.DSL = {

  /**
   * A separator which can be used to separate multiple DSL expressions in one string.
   *
   * @for ProAct.DSL
   * @type String
   * @property separator
   * @final
   */
  separator: &#x27;|&#x27;,

  /**
   * The operation definitions of the DSL.
   * &lt;p&gt;
   *  All of the available and executable operations defined in the ProAct.DSL.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  Users of ProAct.js can add their own operation to it.
   *  &lt;pre&gt;
   *    ProAct.DSL.ops.myOp = ProAct.OpStore.all.simpleOp(&#x27;foo&#x27;, &#x27;foo&#x27;);
   *  &lt;/pre&gt;
   * &lt;/p&gt;
   *
   * @namespace ProAct.DSL
   * @class ops
   * @static
   */
  ops: {

    /**
     * DSL operation for defining sources of {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}}s.
     * &lt;p&gt;
     *  For example
     *  &lt;pre&gt;
     *    &#x27;&lt;&lt;(s:bla)&#x27;
     *  &lt;/pre&gt;
     *  means that the source of the targed of the DSL should be a stream stored in the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} by the key &#x27;bla&#x27;.
     * &lt;/p&gt;
     * &lt;p&gt;
     *  or
     *  &lt;pre&gt;
     *    &#x27;&lt;&lt;($1)&#x27;
     *  &lt;/pre&gt;
     *  means that the source of the targed of the DSL should be an {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} passed to the {{#crossLink &quot;ProAct.DSL/run:method&quot;}}{{/crossLink}}
     *  method as the first argument after the targed object, the DSL data and the registry.
     * &lt;/p&gt;
     *
     * @for ProAct.DSL.ops
     * @final
     * @property into
     * @type Object
     */
    into: opStoreAll.simpleOp(&#x27;into&#x27;, &#x27;&lt;&lt;&#x27;),

    /**
     * DSL operation for setting the targed of the DSL as sources of another {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}}s.
     * &lt;p&gt;
     *  For example
     *  &lt;pre&gt;
     *    &#x27;&gt;&gt;(s:bla)&#x27;
     *  &lt;/pre&gt;
     *  means that the targed of the DSL should become a source for a stream stored in the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} by the key &#x27;bla&#x27;.
     * &lt;/p&gt;
     * &lt;p&gt;
     *  or
     *  &lt;pre&gt;
     *    &#x27;&gt;&gt;($1)&#x27;
     *  &lt;/pre&gt;
     *  means that the targed of the DSL should become a source for an {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} passed to the {{#crossLink &quot;ProAct.DSL/run:method&quot;}}{{/crossLink}}
     *  method as the first argument after the targed object, the DSL data and the registry.
     * &lt;/p&gt;
     *
     * @for ProAct.DSL.ops
     * @final
     * @property out
     * @type Object
     */
    out: opStoreAll.simpleOp(&#x27;out&#x27;, &#x27;&gt;&gt;&#x27;),

    /**
     * DSL operation for attaching listener to the target {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;p&gt;
     *  For example
     *  &lt;pre&gt;
     *    &#x27;@(f:bla)&#x27;
     *  &lt;/pre&gt;
     *  means that listener function, stored in the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} as &#x27;bla&#x27;
     *  should be attached as a listener to the targed {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;/p&gt;
     *
     * @for ProAct.DSL.ops
     * @final
     * @property on
     * @type Object
     */
    on: opStoreAll.simpleOp(&#x27;on&#x27;, &#x27;@&#x27;),

    /**
     * DSL operation for adding mapping to the target {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;p&gt;
     *  For example
     *  &lt;pre&gt;
     *    &#x27;map(f:bla)&#x27;
     *  &lt;/pre&gt;
     *  means that mapping function, stored in the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} as &#x27;bla&#x27;
     *  should be mapped to the targed {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;/p&gt;
     * &lt;p&gt;
     *  or
     *  &lt;pre&gt;
     *    &#x27;map($2)&#x27;
     *  &lt;/pre&gt;
     *  means that mapping function passed to the {{#crossLink &quot;ProAct.DSL/run:method&quot;}}{{/crossLink}}
     *  method as the second argument after the targed object, the DSL data and the registry
     *  should be mapped to the targed {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;/p&gt;
     *
     * @for ProAct.DSL.ops
     * @final
     * @property mapping
     * @type Object
     */
    mapping: opStoreAll.simpleOp(&#x27;mapping&#x27;, &#x27;map&#x27;),

    /**
     * DSL operation for adding filters to the target {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;p&gt;
     *  For example
     *  &lt;pre&gt;
     *    &#x27;filter(f:bla)&#x27;
     *  &lt;/pre&gt;
     *  means that filtering function, stored in the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} as &#x27;bla&#x27;
     *  should be add as filter to the targed {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;/p&gt;
     * &lt;p&gt;
     *  or
     *  &lt;pre&gt;
     *    &#x27;filter($1)&#x27;
     *  &lt;/pre&gt;
     *  means that filtering function passed to the {{#crossLink &quot;ProAct.DSL/run:method&quot;}}{{/crossLink}}
     *  method as the first argument after the targed object, the DSL data and the registry
     *  should be added as filter to the targed {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;/p&gt;
     *
     * @for ProAct.DSL.ops
     * @final
     * @property filtering
     * @type Object
     */
    filtering: opStoreAll.simpleOp(&#x27;filtering&#x27;, &#x27;filter&#x27;),

    /**
     * DSL operation for adding accumulation to the target {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL.
     * &lt;p&gt;
     *  For example
     *  &lt;pre&gt;
     *    &#x27;acc($1, f:bla)&#x27;
     *  &lt;/pre&gt;
     *  means that accumulating function, stored in the {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} as &#x27;bla&#x27;
     *  should be added as accumulation to the targed {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} of the DSL,
     *  and the first argument passed to {{#crossLink &quot;ProAct.DSL/run:method&quot;}}{{/crossLink}} after the targed object, the DSL data and the registry should
     *  be used as initial value for the accumulation.
     * &lt;/p&gt;
     *
     * @for ProAct.DSL.ops
     * @final
     * @property accumulation
     * @type Object
     */
    accumulation: opStoreAll.simpleOp(&#x27;accumulation&#x27;, &#x27;acc&#x27;)
  },

  /**
   * A set of predefined operations to be used by the DSL.
   *
   * @namespace ProAct.DSL
   * @class predefined
   * @static
   */
  predefined: {

    /**
     * A set of predefined mapping operations to be used by the DSL.
     *
     * @class mapping
     * @namespace ProAct.DSL.predefined
     * @static
     */
    mapping: {

      /**
       * Mapping operation for changing the sign of a number to the oposite.
       * &lt;p&gt;
       *  For example 4 becomes -4 and -5 becomes 5.
       * &lt;/p&gt;
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(-)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @final
       * @static
       * @method -
       * @param {Number} n
       *      The number which will have its sign inverted.
       * @return {Number}
       *      The same number as &#x60;n&#x60;, but with opposite sign.
       */
      &#x27;-&#x27;: function (el) { return -el; },

      /**
       * Mapping operation for computing the square of a number.
       * &lt;p&gt;
       *  For example 4 becomes 16.
       * &lt;/p&gt;
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(pow)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method pow
       * @param {Number} n
       *      The number to power.
       * @return {Number}
       *      The square of &#x60;n&#x60;.
       */
      &#x27;pow&#x27;: function (el) { return el * el; },

      /**
       * Mapping operation for computing the square root of a number.
       * &lt;p&gt;
       *  For example 4 becomes 2.
       * &lt;/p&gt;
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(sqrt)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method sqrt
       * @param {Number} n
       *      The number to compute the square root for.
       * @return {Number}
       *      The square root of &#x60;n&#x60;.
       */
      &#x27;sqrt&#x27;: function (el) { return Math.sqrt(el); },

      /**
       * Mapping operation for turning an string to a decimal Number - integer.
       * &lt;p&gt;
       *  For example &#x27;4&#x27; becomes 4.
       * &lt;/p&gt;
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(int)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method int
       * @param {String} str
       *      The string to convert to integer.
       * @return {Number}
       *      The integer representation of &#x60;str&#x60;.
       */
      &#x27;int&#x27;: function (el) { return parseInt(el, 10); },

      /**
       * Mapping operation for calling a method of an object.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(&amp;.&amp;go)
       *  &lt;/pre&gt;
       *  This will call the &#x27;target.go&#x27; method and use its result.
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method &amp;.
       * @param {String} methodName
       *      The method name to call.
       * @return {Object}
       *      The result of the method call.
       */
      &#x27;&amp;.&#x27;: function (arg) {
        return function (el) {
          var p = el[arg];
          if (!p) {
            return el;
          } else if (P.U.isFunction(p)) {
            return p.call(el);
          } else {
            return p;
          }
        };
      },

      /**
       * Mapping operation for turning value in an
       * ProAct.Array pop event.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(pop)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method pop
       * @return {Event}
       *      Pop event.
       */
      pop: function () {
        return P.E.simple(&#x27;array&#x27;, &#x27;pop&#x27;);
      },

      /**
       * Mapping operation for turning value in an
       * ProAct.Array shift event.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(shift)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method shift
       * @return {Event}
       *      Shift event.
       */
      shift: function () {
        return P.E.simple(&#x27;array&#x27;, &#x27;shift&#x27;);
      },

      /**
       * Mapping operation for turning value event in its value.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(eventToVal)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method eventToVal
       * @param {Event} event
       *      The value event to get the new value from.
       * @return {Object}
       *      The value.
       */
      eventToVal: function (event) {
        return event.args[0][event.target];
      },

      /**
       * Maps anything to the constant true.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(true)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method true
       * @param {Object} value
       *      Arbitrary value.
       * @return {Boolean}
       *      Just the &#x60;true&#x60; constant.
       */
      &#x27;true&#x27;: function (event) {
        return true;
      },

      /**
       * Toggles a boolean value. If the value is &#x60;true&#x60; it becomes &#x60;false&#x60; and vice versa.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(!)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method !
       * @param {Boolean} value
       *      A boolean value.
       * @return {Boolean}
       *      The opposite of &#x60;value&#x60;.
       */
      &#x27;!&#x27;: function (value) {
        return !value;
      },

      /**
       * Adds the current time to the object value, called upon
       * If the value is not an object (for example it is a Number), it is returned as it is.
       *
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    map(time)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.mapping
       * @static
       * @method time
       * @param {Object} value
       *      The object to modify with time.
       * @return {Object}
       *      The modified value.
       */
      &#x27;time&#x27;: function (value) {
        if (P.U.isObject(value)) {
          value.time = new Date().getTime();
        }
        return value;
      }
    },

    /**
     * A set of predefined filtering operations to be used by the DSL.
     *
     * @class filtering
     * @namespace ProAct.DSL.predefined
     * @static
     */
    filtering: {

      /**
       * Filtering operation for filtering only odd Numbers.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(odd)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method odd
       * @param {Number} n
       *      The number to check if it is odd.
       * @return {Boolean}
       *      True, if the number is odd.
       */
      &#x27;odd&#x27;: function (el) { return el % 2 !== 0; },

      /**
       * Filtering operation for filtering only even Numbers.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(even)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method even
       * @param {Number} n
       *      The number to check if it is even.
       * @return {Boolean}
       *      True, if the number is even.
       */
      &#x27;even&#x27;: function (el) { return el % 2 === 0; },

      /**
       * Filtering operation for filtering only positive Numbers.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(+)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method +
       * @param {Number} n
       *      The number to check if it is positive.
       * @return {Boolean}
       *      True, if the number is positive or zero.
       */
      &#x27;+&#x27;: function (el) { return el &gt;= 0; },

      /**
       * Filtering operation for filtering only negative Numbers.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(-)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method -
       * @param {Number} n
       *      The number to check if it is negative.
       * @return {Boolean}
       *      True, if the number is negative or zero.
       */
      &#x27;-&#x27;: function (el) { return el &lt;= 0; },

      /**
       * Flitering operation for using a method of an object as a filter.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(&amp;.&amp;boolFunc)
       *  &lt;/pre&gt;
       *  This will call the &#x27;target.boolFunc&#x27; method and use its result as a filter.
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method &amp;.
       * @param {String} methodName
       *      The name of the method to use for filtering.
       * @return {Boolean}
       *      The result of the method call.
       */
      &#x27;&amp;.&#x27;: function (arg) {
        return function (el) {
          if (this.action) {
            return this.action.call(this.context, el);
          }

          var p = el[arg];
          if (!p) {
            return el;
          } else if (P.U.isFunction(p)) {
            this.action = p;
            this.context = el;
          } else {
            return p;
          }
        };
      },

      /**
       * Filtering operation for filtering only values different from undefined.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(defined)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method defined
       * @param {Event} event
       *      The value event to check if its value is defined.
       * @return {Boolean}
       *      True if the value in the event is not &#x60;undefined&#x60;.
       */
      defined: function (event) {
        return event.args[0][event.target] !== undefined;
      },

      /**
       * Filtering operation for filtering only events
       * that have null/undefined as a source.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(originalEvent)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method originalEvent
       * @param {Event} event
       *      The value event to check if it has a source or not.
       * @return {Boolean}
       *      True if the &#x60;event&#x60; passed has no source.
       */
      originalEvent: function (event) {
        return event.source === undefined || event.source === null;
      },

      /**
       * Filtering operation for passing everything.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    filter(all)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.filtering
       * @static
       * @method all
       * @param {Object} val
       *      Anything.
       * @return {Boolean}
       *      True.
       */
      all: function () {
        return true;
      }
    },

    /**
     * A set of predefined accumulation operations to be used by the DSL.
     *
     * @class accumulation
     * @namespace ProAct.DSL.predefined
     * @static
     */
    accumulation: {

      /**
       * Accumulation operation representing a sum of numbers.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    acc(+)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.accumulation
       * @static
       * @property +
       * @type Array
       */
      &#x27;+&#x27;: [0, function (x, y) { return x + y; }],

      /**
       * Accumulation operation representing a product of numbers.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    acc(*)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.accumulation
       * @static
       * @constant
       * @property *
       * @type Array
       */
      &#x27;*&#x27;: [1, function (x, y) { return x * y; }],

      /**
       * Accumulation operation representing string concatenation.
       * &lt;p&gt;
       *  Usage in a DSL expression:
       *  &lt;pre&gt;
       *    acc(+str)
       *  &lt;/pre&gt;
       * &lt;/p&gt;
       *
       * @for ProAct.DSL.predefined.accumulation
       * @static
       * @property +str
       * @type Array
       */
      &#x27;+str&#x27;: [&#x27;&#x27;, function (x, y) { return x + y; }],
    }
  },

  /**
   * Defines a new predefined function to be reused in the DSL.
   *
   * For example:
   * &#x60;&#x60;&#x60;
   *   ProAct.DSL.defPredefined(&#x27;filter&#x27;, &#x27;enter&#x27;, function (event) {
   *    return event.keyCode === 13;
   *   });
   *
   * &#x60;&#x60;&#x60;
   * creates a new &#x60;filtering&#x60; function, which can be used like this:
   * &#x60;&#x60;&#x60;
   *   actor2 = actor1.filter(&#x27;enter&#x27;);
   * &#x60;&#x60;&#x60;
   * the &#x60;actor2&#x60; in this case will recieve only the events with keyCode of &#x60;13&#x60;.
   *
   * @for ProAct.DSL
   * @static
   * @method defPredefined
   * @param {String} type
   *      One of the three -&gt; &#x60;mapping&#x60;, &#x60;filtering&#x60; and &#x60;accumulation&#x60; types.
   * @param {String} id
   *      The identificator of the predefined function to be passed to trasfromation or filtering operations.
   * @param {Function|Array} operation
   *      The implementation of the operation.
   */
  defPredefined: function(type, id, operation) {
    if (type === &#x27;m&#x27; || type === &#x27;map&#x27;) {
      type = &#x27;mapping&#x27;;
    }
    if (type === &#x27;f&#x27; || type === &#x27;filter&#x27;) {
      type = &#x27;filtering&#x27;;
    }
    if (type === &#x27;a&#x27; || type === &#x27;acc&#x27; || type === &#x27;accumulate&#x27;) {
      type = &#x27;accumulation&#x27;;
    }

    ProAct.DSL.predefined[type][id] = operation;
  },

  /**
   * Extracts DSL actions and options from a string.
   * &lt;p&gt;
   *  Splits the passed &lt;i&gt;optionString&lt;/i&gt; using {{#crossLink &quot;ProAct.DSL/separator:property&quot;}}{{/crossLink}} as saparator
   *  and calls {{#crossLink &quot;ProAct.DSL/optionsFromArray:method&quot;}}{{/crossLink}} on the result.
   * &lt;/p&gt;
   *
   * @for ProAct.DSL
   * @static
   * @method optionsFromString
   * @param {String} optionString
   *      The string to use to extract options from.
   * @param [...]
   *      Parameters for the extracted actions/functions/operations.
   *      &lt;p&gt;
   *        For example if the string contains &#x27;map($1)&#x27;, the first argument passed after the &lt;i&gt;optionString&lt;/i&gt; argument
   *        is passed to the &#x27;map&#x27; operation.
   *      &lt;/p&gt;
   * @return {Object}
   *      Object containing operations as fields and options(arguments) for these operations as values.
   *      &lt;p&gt;
   *        &#x27;map($1)|filter(+)|@($2)&#x27; becomes:
   *        &lt;pre&gt;
   *          {
   *            mapping: {first-argument-to-this-function-after-the-optionString-arg},
   *            filtering: ProAct.DSL.predefined.filtering[&#x27;+&#x27;],
   *            on: {second-argument-to-this-function-after-the-optionString-arg}
   *          }
   *        &lt;/pre&gt;
   *      &lt;/p&gt;
   */
  optionsFromString: function (optionString) {
    return dsl.optionsFromArray.apply(null, [optionString.split(dsl.separator)].concat(slice.call(arguments, 1)));
  },

  /**
   * Extracts DSL actions and options from an array of strings.
   * &lt;p&gt;
   *  Example &lt;i&gt;optionArray&lt;/i&gt; is [&#x27;map($1)&#x27;, &#x27;filter(+)&#x27;, @($2)&#x27;] and it will become options object of functions and arguments to
   *  be applied on a target {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} passed to the {{#crossLink &quot;ProAct.DSL/run:method&quot;}}{{/crossLink}} method.
   * &lt;/p&gt;
   *
   * @for ProAct.DSL
   * @static
   * @method optionsFromArray
   * @param {Array} optionArray
   *      The array of strings to use to extract options from.
   * @param [...]
   *      Parameters for the extracted actions/functions/operations.
   *      &lt;p&gt;
   *        For example if the array contains &#x27;map($1)&#x27;, the first argument passed after the &lt;i&gt;optionArray&lt;/i&gt; argument
   *        is passed to the &#x27;map&#x27; operation.
   *      &lt;/p&gt;
   * @return {Object}
   *      Object containing operations as fields and options(arguments) for these operations as values.
   *      &lt;p&gt;
   *        [&#x27;map($1)&#x27;, &#x27;filter(+)&#x27;, @($2)&#x27;] becomes:
   *        &lt;pre&gt;
   *          {
   *            mapping: {first-argument-to-this-function-after-the-optionString-arg},
   *            filtering: ProAct.DSL.predefined.filtering[&#x27;+&#x27;],
   *            on: {second-argument-to-this-function-after-the-optionString-arg}
   *          }
   *        &lt;/pre&gt;
   *      &lt;/p&gt;
   */
  optionsFromArray: function (optionArray) {
    var result = {}, i, ln = optionArray.length,
        ops = P.R.ops, op, opType;
    for (i = 0; i &lt; ln; i++) {
      op = optionArray[i];
      for (opType in P.DSL.ops) {
        opType = P.DSL.ops[opType];
        if (opType.match(op)) {
          opType.toOptions.apply(opType, [result, op].concat(slice.call(arguments, 1)));
          break;
        }
      }
    }
    return result;
  },

  /**
   * Configures an {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} using the DSL passed with the &lt;i&gt;options&lt;/i&gt; argument.
   * &lt;p&gt;
   *  Uses the passed {{#crossLink &quot;ProAct.Registry&quot;}}{{/crossLink}} to read stored values from.
   * &lt;/p&gt;
   *
   * @for ProAct.DSL
   * @static
   * @method
   * @param {ProAct.Actor} actor
   *      The target of the DSL operations.
   * @param {ProAct.Actor|String|Object} options
   *      The DSL formatted options to be used for the configuration.
   *      &lt;p&gt;
   *        If the value of this parameter is instance of {{#crossLink &quot;ProAct.Actor&quot;}}{{/crossLink}} it is set as a source to the &lt;i&gt;target actor&lt;/i&gt;.
   *      &lt;/p&gt;
   *      &lt;p&gt;
   *        If the value ot this parameter is String - {{#crossLink &quot;ProAct.DSL/optionsFromString:method&quot;}}{{/crossLink}} is used to be turned to an options object.
   *      &lt;/p&gt;
   *      &lt;p&gt;
   *        If the values of this parameter is object, it is used to configure the &lt;i&gt;targed actor&lt;/i&gt;.
   *      &lt;/p&gt;
   *      &lt;p&gt;
   *        The format of the object should be something like:
   *        &lt;pre&gt;
   *          {
   *            dsl-operation: function|array-of-functions-and-arguments,
   *            dsl-operation: function|array-of-functions-and-arguments,
   *            dsl-operation: function|array-of-functions-and-arguments,
   *            ...
   *          }
   *        &lt;/pre&gt;
   *      &lt;/p&gt;
   * @param {ProAct.Registry} registry
   *      The registry to read stored values for the DSL operations.
   *      &lt;p&gt;
   *        For example if there is &#x27;map(f:foo)&#x27;, the mapping function is read from the registry at the key &#x27;foo&#x27;.
   *      &lt;/p&gt;
   * @param [...]
   *      Parameters for the DSL operations.
   *      &lt;p&gt;
   *        For example if the array contains &#x27;map($1)&#x27;, the first argument passed after the &lt;i&gt;actor&lt;/i&gt;, &lt;i&gt;options&lt;/i&gt; and &lt;i&gt;registry&lt;/i&gt; arguments
   *        is passed to the &#x27;map&#x27; operation.
   *      &lt;/p&gt;
   * @return {ProAct.Actor}
   *      The configured actor.
   */
  run: function (actor, options, registry) {
    var isS = P.U.isString,
        args = slice.call(arguments, 3),
        option, i, ln, opType, oldOption,
        multiple = {};

    if (options &amp;&amp; isS(options)) {
      options = dsl.optionsFromString.apply(null, [options].concat(args));
    }

    if (options &amp;&amp; options instanceof P.Actor) {
      options = {into: options};
    }

    if (options &amp;&amp; options.order) {
      ln = options.order.length;
      for (i = 0; i &lt; ln; i++) {
        option = options.order[i];
        if (opType = dslOps[option]) {
          if (registry) {
            if (options.order.indexOf(option) !== options.order.lastIndexOf(option)) {
              if (multiple[option] === undefined) {
                multiple[option] = -1;
              }
              multiple[option] = multiple[option] + 1;
              oldOption = options[option];
              options[option] = options[option][multiple[option]];
            }
            options[option] = registry.toObjectArray(options[option]);
          }

          opType.action(actor, options);
          if (oldOption) {
            options[option] = oldOption;
            oldOption = undefined;

            if (multiple[option] &gt;= options[option].length - 1) {
              delete options[option];
            }
          } else {
            delete options[option];
          }
        }
      }
    }

    for (opType in dslOps) {
      if (options &amp;&amp; (option = options[opType])) {
        options[opType] = registry.toObjectArray(option);
      }
      opType = dslOps[opType];
      opType.action(actor, options);
    }

    return actor;
  }
};

dsl = P.DSL;
dslOps = dsl.ops;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
