<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/js/core/actor.js - proact.js</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
	    <img alt="proact.js" src="../../proact_logo_icon.png" style="max-height: 65%;" title="proact.js">
        
            proact.js
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.3.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/ProAct", "classes/ProAct.Actor", "classes/ProAct.ActorUtil", "classes/ProAct.Array", "classes/ProAct.Array.Listeners", "classes/ProAct.Array.Operations", "classes/ProAct.ArrayCore", "classes/ProAct.ArrayProperty", "classes/ProAct.ArrayPropertyProvider", "classes/ProAct.ArrayUtils", "classes/ProAct.AutoProperty", "classes/ProAct.AutoPropertyProvider", "classes/ProAct.BufferedStream", "classes/ProAct.Configuration", "classes/ProAct.Core", "classes/ProAct.DebouncingStream", "classes/ProAct.DelayedStream", "classes/ProAct.DSL", "classes/ProAct.DSL.ops", "classes/ProAct.DSL.predefined", "classes/ProAct.DSL.predefined.accumulation", "classes/ProAct.DSL.predefined.filtering", "classes/ProAct.DSL.predefined.mapping", "classes/ProAct.Event", "classes/ProAct.Event.Types", "classes/ProAct.Flow", "classes/ProAct.ObjectCore", "classes/ProAct.ObjectProperty", "classes/ProAct.ObjectPropertyProvider", "classes/ProAct.OpStore", "classes/ProAct.OpStore.all", "classes/ProAct.ProbProvider", "classes/ProAct.Property", "classes/ProAct.Property.Types", "classes/ProAct.PropertyProvider", "classes/ProAct.ProxyProperty", "classes/ProAct.ProxyPropertyProvider", "classes/ProAct.Queue", "classes/ProAct.Queues", "classes/ProAct.Registry", "classes/ProAct.Registry.FunctionProvider", "classes/ProAct.Registry.ProObjectProvider", "classes/ProAct.Registry.ProObjectProvider.types", "classes/ProAct.Registry.Provider", "classes/ProAct.Registry.Provider.types", "classes/ProAct.Registry.StreamProvider", "classes/ProAct.Registry.StreamProvider.types", "classes/ProAct.SimplePropertyProvider", "classes/ProAct.SizeBufferedStream", "classes/ProAct.States", "classes/ProAct.Stream", "classes/ProAct.SubscribableStream", "classes/ProAct.ThrottlingStream", "classes/ProAct.Utils", "classes/ProAct.ValueEvent", "modules/proact-arrays", "modules/proact-core", "modules/proact-dsl", "modules/proact-flow", "modules/proact-properties", "modules/proact-streams"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <h3>APIs</h3>
    <div id="sidebar">
        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
            <li><a href="#modules" data-toggle="tab">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" placeholder="Type to filter APIs">
        </div>

        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
            <div class="tab-pane active" id="classes">
                <ul id="api-classes" class="nav nav-list">
                    
                        <li><a href="../classes/ProAct.html">ProAct</a></li>
                    
                        <li><a href="../classes/ProAct.Actor.html">ProAct.Actor</a></li>
                    
                        <li><a href="../classes/ProAct.Array.html">ProAct.Array</a></li>
                    
                        <li><a href="../classes/ProAct.Array.Listeners.html">ProAct.Array.Listeners</a></li>
                    
                        <li><a href="../classes/ProAct.Array.Operations.html">ProAct.Array.Operations</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayCore.html">ProAct.ArrayCore</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayProperty.html">ProAct.ArrayProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayPropertyProvider.html">ProAct.ArrayPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.ArrayUtils.html">ProAct.ArrayUtils</a></li>
                    
                        <li><a href="../classes/ProAct.AutoProperty.html">ProAct.AutoProperty</a></li>
                    
                        <li><a href="../classes/ProAct.AutoPropertyProvider.html">ProAct.AutoPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.BufferedStream.html">ProAct.BufferedStream</a></li>
                    
                        <li><a href="../classes/ProAct.Configuration.html">ProAct.Configuration</a></li>
                    
                        <li><a href="../classes/ProAct.Core.html">ProAct.Core</a></li>
                    
                        <li><a href="../classes/ProAct.DebouncingStream.html">ProAct.DebouncingStream</a></li>
                    
                        <li><a href="../classes/ProAct.DelayedStream.html">ProAct.DelayedStream</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.html">ProAct.DSL</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.ops.html">ProAct.DSL.ops</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.html">ProAct.DSL.predefined</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.accumulation.html">ProAct.DSL.predefined.accumulation</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.filtering.html">ProAct.DSL.predefined.filtering</a></li>
                    
                        <li><a href="../classes/ProAct.DSL.predefined.mapping.html">ProAct.DSL.predefined.mapping</a></li>
                    
                        <li><a href="../classes/ProAct.Event.html">ProAct.Event</a></li>
                    
                        <li><a href="../classes/ProAct.Event.Types.html">ProAct.Event.Types</a></li>
                    
                        <li><a href="../classes/ProAct.Flow.html">ProAct.Flow</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectCore.html">ProAct.ObjectCore</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectProperty.html">ProAct.ObjectProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ObjectPropertyProvider.html">ProAct.ObjectPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.OpStore.html">ProAct.OpStore</a></li>
                    
                        <li><a href="../classes/ProAct.OpStore.all.html">ProAct.OpStore.all</a></li>
                    
                        <li><a href="../classes/ProAct.ProbProvider.html">ProAct.ProbProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Property.html">ProAct.Property</a></li>
                    
                        <li><a href="../classes/ProAct.Property.Types.html">ProAct.Property.Types</a></li>
                    
                        <li><a href="../classes/ProAct.PropertyProvider.html">ProAct.PropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.ProxyProperty.html">ProAct.ProxyProperty</a></li>
                    
                        <li><a href="../classes/ProAct.ProxyPropertyProvider.html">ProAct.ProxyPropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Queue.html">ProAct.Queue</a></li>
                    
                        <li><a href="../classes/ProAct.Queues.html">ProAct.Queues</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.html">ProAct.Registry</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.FunctionProvider.html">ProAct.Registry.FunctionProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.ProObjectProvider.html">ProAct.Registry.ProObjectProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.ProObjectProvider.types.html">ProAct.Registry.ProObjectProvider.types</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.Provider.html">ProAct.Registry.Provider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.Provider.types.html">ProAct.Registry.Provider.types</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.StreamProvider.html">ProAct.Registry.StreamProvider</a></li>
                    
                        <li><a href="../classes/ProAct.Registry.StreamProvider.types.html">ProAct.Registry.StreamProvider.types</a></li>
                    
                        <li><a href="../classes/ProAct.SimplePropertyProvider.html">ProAct.SimplePropertyProvider</a></li>
                    
                        <li><a href="../classes/ProAct.SizeBufferedStream.html">ProAct.SizeBufferedStream</a></li>
                    
                        <li><a href="../classes/ProAct.States.html">ProAct.States</a></li>
                    
                        <li><a href="../classes/ProAct.Stream.html">ProAct.Stream</a></li>
                    
                        <li><a href="../classes/ProAct.SubscribableStream.html">ProAct.SubscribableStream</a></li>
                    
                        <li><a href="../classes/ProAct.ThrottlingStream.html">ProAct.ThrottlingStream</a></li>
                    
                        <li><a href="../classes/ProAct.Utils.html">ProAct.Utils</a></li>
                    
                        <li><a href="../classes/ProAct.ValueEvent.html">ProAct.ValueEvent</a></li>
                    
                </ul>
            </div>

            <div class="tab-pane" id="modules">
                <ul id="api-modules" class="nav nav-list">
                    
                        <li><a href="../modules/proact-arrays.html">proact-arrays</a></li>
                    
                        <li><a href="../modules/proact-core.html">proact-core</a></li>
                    
                        <li><a href="../modules/proact-dsl.html">proact-dsl</a></li>
                    
                        <li><a href="../modules/proact-flow.html">proact-flow</a></li>
                    
                        <li><a href="../modules/proact-properties.html">proact-properties</a></li>
                    
                        <li><a href="../modules/proact-streams.html">proact-streams</a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>src/js/core/actor.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/**
 * @module proact-core
 */

/**
 * &lt;p&gt;
 *  &#x60;ProAct.Actor&#x60; is the basic observer-observable functionallity in ProAct.js
 * &lt;/p&gt;
 * &lt;p&gt;
 *  The actors in ProAct.js form the dependency graph.
 *  If some actor listens to changes from another - it depends on it.
 * &lt;/p&gt;
 * &lt;p&gt;
 *  The actors can transform the values or events incoming to them.
 * &lt;/p&gt;
 * &lt;p&gt;
 *  Every actor can have a parent actor, that will be notified for all the changes
 *  on the child-actor, it is something as special observer.
 * &lt;/p&gt;
 * &lt;p&gt;
 *  ProAct.Actor is part of the core module of ProAct.js.
    System.out.println();
 * &lt;/p&gt;
 *
 * @class ProAct.Actor
 * @constructor
 * @param {String} [queueName]
 *      The name of the queue all the updates should be pushed to.
 *      &lt;p&gt;
 *        If this parameter is null/undefined the default queue of
 *        {{#crossLink &quot;ProAct/flow:property&quot;}}{{/crossLink}} is used.
 *      &lt;/p&gt;
 *      &lt;p&gt;
 *        If this parameter is not a string it is used as the
 *        &lt;i&gt;transforms&lt;/i&gt;.
 *      &lt;/p&gt;
 * @param {Array} [transforms]
 *      A list of transformation to be used on all incoming chages.
 */
function Actor (queueName, transforms) {
  if (queueName &amp;&amp; !P.U.isString(queueName)) {
    transforms = queueName;
    queueName = null;
  }

  P.U.defValProp(this, &#x27;listeners&#x27;, false, false, true, this.defaultListeners());

  P.U.defValProp(this, &#x27;listener&#x27;, false, false, true, null);
  P.U.defValProp(this, &#x27;errListener&#x27;, false, false, true, null);
  P.U.defValProp(this, &#x27;closeListener&#x27;, false, false, true, null);
  P.U.defValProp(this, &#x27;parent&#x27;, false, false, true, null);

  P.U.defValProp(this, &#x27;queueName&#x27;, false, false, false, queueName);
  P.U.defValProp(this, &#x27;transforms&#x27;, false, false, true,
                 (transforms ? transforms : []));

  P.U.defValProp(this, &#x27;state&#x27;, false, false, true, P.States.init);

  this.init();
}
ProAct.Actor = P.Pro = Actor;

P.U.ex(P.Actor, {

  /**
   * A constant defining bad values or bad events.
   *
   * Part of the filtering mechainsm; If a transformation returns
   * a &#x60;BadValue&#x60;, based on uncomming event -&gt; the event is skipped.
   *
   * @property BadValue
   * @type Object
   * @final
   * @static
   * @for ProAct.Actor
   */
  BadValue: {},

  /**
   * A constant defining closing or ending events.
   *
   * If a transformation returns this value, the actor will be closed.
   *
   * You can manually close &#x60;Actor&#x60;s updating them with this constant as an event.
   *
   * @property Close
   * @type Object
   * @final
   * @static
   * @for ProAct.Actor
   */
  Close: {},

  /**
   * Transforms the passed &lt;i&gt;val&lt;/i&gt; using the {{#crossLink &quot;ProAct.Actor/transforms:method&quot;}}{{/crossLink}} method of the passed &lt;i&gt;actor&lt;/i&gt;.
   *
   * @method transforms
   * @for ProAct.Actor
   * @static
   * @param {ProAct.Actor} actor The &#x60;ProAct.Actor&#x60; which transformations should be used.
   * @param {Object} val The value to transform.
   * @return {Object} The transformed value.
   */
  transform: function (actor, val) {
    var i, t = actor.transforms, ln = t.length;
    for (i = 0; i &lt; ln; i++) {
      val = t[i].call(actor, val);
      if (val === P.Actor.BadValue) {
        break;
      }

      if (val === P.Actor.Close) {
        break;
      }
    }

    return val;
  }
});

P.Actor.prototype = {

  /**
   * Reference to the constructor of this object.
   *
   * @property constructor
   * @type ProAct.Actor
   * @final
   * @for ProAct.Actor
   */
  constructor: ProAct.Actor,

  /**
   * Initializes this actor.
   * &lt;p&gt;
   *  This method logic is run only if the current state of &lt;i&gt;this&lt;/i&gt; is
   *  {{#crossLink &quot;ProAct.States/init:property&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  Then {{#crossLink &quot;ProAct.Actor/afterInit:method&quot;}}{{/crossLink}} is called to finish the initialization.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @method init
   */
  init: function () {
    if (this.state !== P.States.init) {
      return;
    }

    this.doInit();

    this.afterInit();
  },

  /**
   * Allocating of resources or initializing is done here.
   * &lt;p&gt;
   *  Empty by default.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @protected
   * @method doInit
   */
  doInit: function () {},

  /**
   * Called automatically after initialization of this actor.
   * &lt;p&gt;
   *  By default it changes the state of &lt;i&gt;this&lt;/i&gt; to {{#crossLink &quot;ProAct.States/ready:property&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  It can be overridden to define more complex initialization logic.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @protected
   * @method afterInit
   */
  afterInit: function () {
    this.state = P.States.ready;
  },

  /**
   * Closes this actor =&gt; it state becomes {{#crossLink &quot;ProAct.States/closed:property&quot;}}{{/crossLink}}.
   *
   * This sends a &#x60;close&#x60; event to all the subscribers to closing.
   *
   * After closing the actor it can&#x27;t emit events anymore.
   *
   * Example:
   * &#x60;&#x60;&#x60;
   *  var actor = new ProAct.Actor();
   *  actor.onClose(function () {
   *    console.log(&#x27;Done!&#x27;);
   *  });
   *
   *  actor.close(); // We will see &#x27;Done!&#x27; on the console output.
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @method close
   * @return {ProAct.Actor} This instance - can be chained.
   */
  close: function () {
    if (this.state === P.States.closed) {
      return;
    }
    return ActorUtil.update.call(this, P.Actor.Close, &#x27;close&#x27;);
  },

  /**
   * Checks if &lt;i&gt;this&lt;/i&gt; can be closed.
   * &lt;p&gt;
   *  Defaults to return true.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @protected
   * @instance
   * @method canClose
   */
  canClose: function () {
    return true;
  },

  /**
   * This method is called when a &#x60;close&#x60; event is pushed to this &#x60;Actor&#x60;.
   *
   * It removes all the subscriptions to the &#x60;Actor&#x60; and sets its
   * state to {{#crossLink &quot;ProAct.States/closed:property&quot;}}{{/crossLink}}.
   *
   * Do not call this method; it is private!
   *
   * @for ProAct.Actor
   * @private
   * @instance
   * @protected
   * @method doClose
   */
  doClose: function () {
    this.state = P.States.closed;
    this.offAll();
    if (this.listener) {
      this.listener.closed = true;
    }
  },

  /**
   * Called immediately before destruction.
   *
   * The idea is to be implemented by extenders to free additional resources on destroy.
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @protected
   * @method beforeDestroy
   */
  beforeDestroy: function () {
  },

  /**
   * Destroys this &#x60;ProAct.Actor&#x60; instance.
   * &lt;p&gt;
   *  The state of &lt;i&gt;this&lt;/i&gt; is set to {{#crossLink &quot;ProAct.States/destroyed:property&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   *
   * Calls {{#crossLink &quot;ProAct.Actor/beforeDestroy:method&quot;}}{{/crossLink}}
   *
   * @for ProAct.Actor
   * @instance
   * @method destroy
   */
  destroy: function () {
    if (this.state === P.States.destroyed) {
      return;
    }

    this.beforeDestroy();

    this.listeners = undefined;

    if (this.listener) {
      this.listener.destroyed = true;
    }
    this.listener = undefined;
    this.errListener = undefined;
    this.closeListener = undefined;
    this.parent = undefined;

    this.queueName = undefined;
    this.transforms = undefined;

    this.state = P.States.destroyed;
  },

  /**
   * Generates the initial listeners object.
   * It can be overridden for alternative listeners collections.
   * It is used for resetting all the listeners too.
   *
   * The default types of listeners are:
   * &#x60;&#x60;&#x60;
   *  {
   *    change: [],
   *    error: [],
   *    close: []
   *  }
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @protected
   * @method defaultListeners
   * @return {Object} A map containing the default listeners collections.
   */
  defaultListeners: function () {
    return {
      change: [],
      error: [],
      close: []
    };
  },

  /**
   * A list of actions or action to be used when no action is passed for the methods working with actions.
   *
   * @for ProAct.Actor
   * @instance
   * @method defaultActions
   * @protected
   * @default &#x27;change&#x27;
   * @return {Array|String} The actions to be used if no actions are provided to action related methods, like
   *  {{#crossLink &quot;ProAct.Actor/on:method&quot;}}{{/crossLink}},
   *  {{#crossLink &quot;ProAct.Actor/off:method&quot;}}{{/crossLink}},
   *  {{#crossLink &quot;ProAct.ActorUtil/update:method&quot;}}{{/crossLink}}.
   */
  defaultActions: function () {
    return &#x27;change&#x27;;
  },

  /**
   * Creates the &lt;i&gt;listener&lt;/i&gt; of this actor.
   *
   * Every actor should have one listener that should pass to other actors.
   *
   * &lt;p&gt;
   *  This listener turns the actor in a observer.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  Should be overriden with specific listener, by default it returns {{#crossLink &quot;ProAct/N:method&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @method makeListener
   * @protected
   * @default {ProAct.N}
   * @return {Object} The &lt;i&gt;listener of this observer&lt;/i&gt;.
   */
  makeListener: P.N,

  /**
   * Creates the &lt;i&gt;error listener&lt;/i&gt; of this actor.
   *
   * Every actor should have one error listener that should pass to other actors.
   *
   * &lt;p&gt;
   *  This listener turns the actor in a observer for errors.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  Should be overriden with specific listener, by default it returns {{#crossLink &quot;ProAct/N:method&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @method makeErrListener
   * @protected
   * @default {ProAct.N}
   * @return {Object} The &lt;i&gt;error listener of this observer&lt;/i&gt;.
   */
  makeErrListener: P.N,

  /**
   * Creates the &lt;i&gt;closing listener&lt;/i&gt; of this actor.
   *
   * Every actor should have one closing listener that should pass to other actors.
   *
   * &lt;p&gt;
   *  This listener turns the actor in a observer for closing events.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  Should be overriden with specific listener, by default it returns {{#crossLink &quot;ProAct/N:method&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @protected
   * @method makeCloseListener
   * @default {ProAct.N}
   * @return {Object} The &lt;i&gt;closing listener of this observer&lt;/i&gt;.
   */
  makeCloseListener: P.N,

  /**
   * Creates the &lt;i&gt;event&lt;/i&gt; to be send to the listeners on update.
   *
   * &lt;p&gt;
   *  The &lt;i&gt;event&lt;/i&gt; should be an instance of {{#crossLink &quot;ProAct.Event&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   *  By default this method returns {{#crossLink &quot;ProAct.Event.Types/value:property&quot;}}{{/crossLink}} event.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @method makeEvent
   * @default {ProAct.Event} with type {{#crossLink &quot;ProAct.Event.Types/value:property&quot;}}{{/crossLink}}.
   * @protected
   * @param {ProAct.Event} source The source event of the event. It can be null
   * @return {ProAct.Event} The event.
   */
  makeEvent: function (source) {
    return new P.Event(source, this, P.Event.Types.value);
  },

  /**
   * Attaches a new listener to this &#x60;ProAct.Actor&#x60;.
   *
   * The listener may be function or object that defines a &lt;i&gt;call&lt;/i&gt; method.
   *
   * &#x60;&#x60;&#x60;
   *   actor.on(function (v) {
   *    console.log(v);
   *   });
   *
   *   actor.on(&#x27;error&#x27;, function (v) {
   *    console.error(v);
   *   });
   *
   *   actor.on({
   *    call: function (v) {
   *      console.log(v);
   *    }
   *   });
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @method on
   * @param {Array|String} actions
   *      The action/actions to listen for. If this parameter is skipped or null/undefined,
   *      the actions from {{#crossLink &quot;ProAct.Actor/defaultActions:method&quot;}}{{/crossLink}} are used.
   *      &lt;p&gt;
   *        The actions can be skipped and on their place as first parameter to be passed the &lt;i&gt;listener&lt;/i&gt;.
   *      &lt;/p&gt;
   * @param {Object} listener
   *      The listener to attach. It must be instance of Function or object with a &lt;i&gt;call&lt;/i&gt; method.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  on: function (actions, listener) {
    if (!P.U.isString(actions) &amp;&amp; !P.U.isArray(actions)) {
      listener = actions;
      actions = this.defaultActions();
    }
    if (!P.U.isArray(actions)) {
      actions = [actions];
    }

    var ln = actions.length,
        action, i, listeners;

    for (i = 0; i &lt; ln; i ++) {
      action = actions[i];
      listeners = this.listeners[action];

      if (!listeners) {
        listeners = this.listeners[action] = [];
      }

      listeners.push(listener);
    }

    return this;
  },

  /**
   * Removes a &lt;i&gt;listener&lt;/i&gt; from the passed &lt;i&gt;action&lt;/i&gt;.
   *
   * &lt;p&gt;
   *  If this method is called without parameters, all the listeners for all the actions are removed.
   *  The listeners are reset using {{#crossLink &quot;ProAct.Actor/defaultActions:method&quot;}}{{/crossLink}}.
   * &lt;/p&gt;
   *
   * Examples are:
   *
   * Removing a listener:
   * &#x60;&#x60;&#x60;
   *  var listener = function (v) {
   *    console.log(v);
   *  };
   *  actor.on(listener);
   *  actor.off(listener);
   * &#x60;&#x60;&#x60;
   *
   * Or for removing all the listeners attached to an actor:
   * &#x60;&#x60;&#x60;
   *  actor.off();
   * &#x60;&#x60;&#x60;
   *
   * Or for removing all the listeners of a given type attached to an actor:
   * &#x60;&#x60;&#x60;
   *  actor.off(&#x27;error&#x27;);
   * &#x60;&#x60;&#x60;
   *
   * Or for removing a listener from different type of actions:
   * &#x60;&#x60;&#x60;
   *  var listener = function (v) {
   *    console.log(v);
   *  };
   *  actor.on(listener);
   *  actor.onErr(listener);
   *
   *  actor.off([&#x27;error&#x27;, &#x27;change&#x27;], listener);
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @method off
   * @param {Array|String} actions
   *      The action/actions to stop listening for. If this parameter is skipped or null/undefined,
   *      the actions from {{#crossLink &quot;ProAct.Actor/defaultActions:method&quot;}}{{/crossLink}} are used.
   *      &lt;p&gt;
   *        The actions can be skipped and on their place as first parameter to be passed the &lt;i&gt;listener&lt;/i&gt;.
   *      &lt;/p&gt;
   * @param {Object} listener
   *      The listener to detach. If it is skipped, null or undefined all the listeners are removed from this actor.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  off: function (actions, listener) {
    if (!actions &amp;&amp; !listener) {
      this.listeners = this.defaultListeners();
      return this;
    }

    if (!P.U.isString(actions) &amp;&amp; !P.U.isArray(actions)) {
      listener = actions;
      actions = this.defaultActions();
    }
    if (!P.U.isArray(actions)) {
      actions = [actions];
    }

    var ln = actions.length,
        action, i, listeners;

    for (i = 0; i &lt; ln; i ++) {
      action = actions[i];
      listeners = this.listeners[action];

      if (listeners) {
        P.U.remove(listeners, listener);
      }
    }

    return this;
  },

  /**
   * Attaches a new error listener to this ProAct.Actor.
   *
   * The listener may be function or object that defines a &lt;i&gt;call&lt;/i&gt; method.
   *
   * This is the same as calling &#x60;on(&#x27;error&#x27;, listener)&#x60; on an &#x60;Actor&#x60;...
   *
   * @for ProAct.Actor
   * @instance
   * @method onErr
   * @param {Object} listener
   *      The listener to attach. It must be instance of Function or object with a &lt;i&gt;call&lt;/i&gt; method.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  onErr: function (listener) {
    return this.on(&#x27;error&#x27;, listener);
  },

  /**
   * Removes an error &lt;i&gt;listener&lt;/i&gt; from the passed &lt;i&gt;action&lt;/i&gt;.
   *
   * This is the same as calling &#x60;off(&#x27;error&#x27;, listener)&#x60; on an &#x60;Actor&#x60;...
   *
   * @for ProAct.Actor
   * @instance
   * @method offErr
   * @param {Object} listener
   *      The listener to detach. If it is skipped, null or undefined all the listeners are removed from this actor.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  offErr: function (listener) {
    return this.off(&#x27;error&#x27;, listener);
  },

  /**
   * Attaches a new close notifcation listener to this &#x60;ProAct.Actor&#x60;.
   *
   * The listener may be function or object that defines a &lt;i&gt;call&lt;/i&gt; method.
   *
   * This is the same as calling &#x60;on(&#x27;close&#x27;, listener)&#x60; on an &#x60;Actor&#x60;...
   *
   * @for ProAct.Actor
   * @instance
   * @method onClose
   * @param {Object} listener
   *      The listener to attach. It must be instance of Function or object with a &lt;i&gt;call&lt;/i&gt; method.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  onClose: function (listener) {
    return this.on(&#x27;close&#x27;, listener);
  },

  /**
   * Removes a close notification &lt;i&gt;listener&lt;/i&gt; from the passed &lt;i&gt;action&lt;/i&gt;.
   *
   * This is the same as calling &#x60;off(&#x27;close&#x27;, listener)&#x60; on an &#x60;Actor&#x60;...
   *
   * @for ProAct.Actor
   * @instance
   * @method offClose
   * @param {Object} listener
   *      The listener to detach. If it is skipped, null or undefined all the listeners are removed from this actor.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  offClose: function (listener) {
    return this.off(&#x27;close&#x27;, listener);
  },

  /**
   * Attaches the passed listener to listen to values, errors and the close notification from this &#x60;ProAct.Actor&#x60;.
   *
   * The listener may be function or object that defines a &lt;i&gt;call&lt;/i&gt; method.
   *
   * @for ProAct.Actor
   * @instance
   * @method onAll
   * @param {Object} listener
   *      The listener to attach. It must be instance of Function or object with a &lt;i&gt;call&lt;/i&gt; method.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  onAll: function (listener) {
    return this.on(listener).onClose(listener).onErr(listener);
  },

  /**
   * Removes all notifications &lt;i&gt;listener&lt;/i&gt; from the passed &lt;i&gt;action&lt;/i&gt;.
   *
   * @for ProAct.Actor
   * @instance
   * @method offAll
   * @param {Object} listener
   *      The listener to detach. If it is skipped, null or undefined all the listeners are removed from this actor.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  offAll: function (listener) {
    this.off(listener);
    this.off(&#x27;error&#x27;, listener);
    return this.off(&#x27;close&#x27;, listener);
  },

  /**
   * Links source actors into this actor. This means that &lt;i&gt;this actor&lt;/i&gt;
   * is listening for changes from the &lt;i&gt;sources&lt;/i&gt;.
   * &lt;p&gt;
   *  A good example is one stream to have another as as source -&gt; if data comes into the source
   *  stream, it is passed to the listening too. That way the source stream is plugged &lt;b&gt;into&lt;/b&gt; the listening one.
   * &lt;/p&gt;
   * &lt;p&gt;
   *  The listeners from {{#crossLink &quot;ProAct.Actor/makeListener:method&quot;}}{{/crossLink}},
   *  {{#crossLink &quot;ProAct.Actor/makeErrListener:method&quot;}}{{/crossLink}} and {{#crossLink &quot;ProAct.Actor/makeCloseListener:method&quot;}}{{/crossLink}} are used.
   * &lt;/p&gt;
   *
   * Chaining actors is very powerful operation. It can be used to merge many source actors into one.
   *
   * &#x60;&#x60;&#x60;
   *  var sourceActor1 = &lt;Actor implementation&gt;;
   *  var sourceActor2 = &lt;Actor implementation&gt;;
   *  var actor = &lt;Actor implementation&gt;;
   *
   *  actor.into(sourceActor1, sourceActor2);
   *  actor.on(function (v) {
   *    console.log(v);
   *  });
   *
   * &#x60;&#x60;&#x60;
   *
   * Now if the any of the source actors is updated, the update will be printed on the console by the &#x60;actor&#x60;.
   *
   * @for ProAct.Actor
   * @instance
   * @method into
   * @param [...]
   *      Zero or more source ProAct.Actors to set as sources.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  into: function () {
    var args = slice.call(arguments),
        ln = args.length, i, source;
    for (i = 0; i &lt; ln; i++) {
      source = args[i];
      source.on(this.makeListener());
      source.onErr(this.makeErrListener());
      source.onClose(this.makeCloseListener());
    }

    return this;
  },

  /**
   * The reverse of {{#crossLink &quot;ProAct.Actor/into:method&quot;}}{{/crossLink}} - sets &lt;i&gt;this actor&lt;/i&gt; as a source
   * to the passed &lt;i&gt;destination&lt;/i&gt; actor.
   *
   * &#x60;&#x60;&#x60;
   *  var sourceActor = &lt;Actor implementation&gt;;
   *  var actor = &lt;Actor implementation&gt;;
   *
   *  sourceActor.out(actor);
   *  actor.on(function (v) {
   *    console.log(v);
   *  });
   *
   *  Now if the any of the source actors is updated, the update will be printed on the console by the &#x60;actor&#x60;.
   *
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @method out
   * @param {ProAct.Actor} destination
   *      The actor to set as source &lt;i&gt;this&lt;/i&gt; to.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  out: function (destination) {
    destination.into(this);

    return this;
  },

  /**
   * Adds a new &lt;i&gt;transformation&lt;/i&gt; to the list of transformations
   * of &lt;i&gt;this actor&lt;/i&gt;.
   *
   * &lt;p&gt;
   *  A transformation is a function or an object that has a &lt;i&gt;call&lt;/i&gt; method defined.
   *  This function or call method should have one argument and to return a transformed version of it.
   *  If the returned value is {@link ProAct.Actor.BadValue}, the next transformations are skipped and the updating
   *  value/event becomes - bad value.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   *  Every value/event that updates &lt;i&gt;this actor&lt;/i&gt; will be transformed using the new transformation.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @method transform
   * @protected
   * @param {Object} transformation
   *      The transformation to add.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  transform: function (transformation) {
    this.transforms.push(transformation);
    return this;
  },

  /**
   * Adds a new &lt;i&gt;transformation&lt;/i&gt; to the list of transformations
   * of &lt;i&gt;this actor&lt;/i&gt;.
   *
   * A transformation is a function or an object that has a &lt;i&gt;call&lt;/i&gt; method defined.
   * This function or call method should have one argument and to return a transformed version of it.
   * If the returned value is {@link ProAct.Actor.BadValue}, the next transformations are skipped and the updating
   * value/event becomes - bad value.
   *
   * Every value/event that updates &lt;i&gt;this actor&lt;/i&gt; will be transformed using the new transformation.
   *
   * The idea of this method is that it just calls {{#crossLink &quot;ProAct.Actor/transform:method&quot;}}{{/crossLink}},
   * but it can be overidden from another module.
   *
   * TODO Maybe transformStored is a bad name 
   *
   * @for ProAct.Actor
   * @instance
   * @method transformStored
   * @protected
   * @param {Object} transformation
   *      The transformation to add. Can be string - to be retrieved by name.
   * @param {String} type
   *      The type of the transformation, for example &#x60;mapping&#x60;.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  transformStored: function (transformation, type) {
    return this.transform(transformation);
  },

  /**
   * Adds a mapping transformation to &lt;i&gt;this actor&lt;/i&gt;.
   * &lt;p&gt;
   *  Mapping transformations just transform one value into another. For example if we get update with
   *  the value of &lt;i&gt;3&lt;/i&gt; and we have mapping transformation that returns the updating value powered by &lt;i&gt;2&lt;/i&gt;,
   *  we&#x27;ll get &lt;i&gt;9&lt;/i&gt; as actual updating value.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @protected
   * @instance
   * @method mapping
   * @param {Object} mappingFunction
   *      Function or object with a &lt;i&gt;call method&lt;/i&gt; to use as map function.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  mapping: function (mappingFunction) {
    return this.transformStored(mappingFunction, &#x27;map&#x27;);
  },

  /**
   * Adds a filtering transformation to &lt;i&gt;this actor&lt;/i&gt;.
   * &lt;p&gt;
   *  Filtering can be used to filter the incoming update values. For example you can
   *  filter by only odd numbers as update values.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @protected
   * @method filtering
   * @param {Object} filteringFunction
   *      The filtering function or object with a call method, should return boolean.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  filtering: function(filteringFunction) {
    var self = this,
    filter = filteringFunction.call ? function (val) {
      if (filteringFunction.call(self, val)) {
        return val;
      };
      return P.Actor.BadValue;
    } : filteringFunction;

    return this.transformStored(filter, &#x27;filter&#x27;);
  },

  /**
   * Adds an accumulation transformation to &lt;i&gt;this actor&lt;/i&gt;.
   * &lt;p&gt;
   *  Accumulation is used to compute a value based on the previous one.
   * &lt;/p&gt;
   *
   * @for ProAct.Actor
   * @instance
   * @protected
   * @method accumulation
   * @param {Object} initVal
   *      Initial value for the accumulation. For example &#x27;0&#x27; for sum.
   * @param {Object} accumulationFunction
   *      The function to accumulate.
   * @return {ProAct.Actor}
   *      &lt;b&gt;this&lt;/b&gt;
   */
  accumulation: function (initVal, accumulationFunction) {
    if (!accumulationFunction) {
      accumulationFunction = initVal;
      initVal = undefined;
    }

    var self = this,
        val = initVal,
        acc = accumulationFunction.call ? function (newVal) {
          val = accumulationFunction.call(self, val, newVal)
          return val;
        } : accumulationFunction;
    return this.transformStored(acc, &#x27;acc&#x27;);
  },

  /**
   * Creates a new ProAct.Actor instance with source &lt;i&gt;this&lt;/i&gt; and mapping
   * the passed &lt;i&gt;mapping function&lt;/i&gt;.
   * &lt;p&gt;
   *  Should be overridden with creating the right actor.
   * &lt;/p&gt;
   *
   * &#x60;&#x60;&#x60;
   *  var actor = sourceActor.map(function (el) {
   *    return el * el;
   *  });
   * &#x60;&#x60;&#x60;
   *
   * or
   *
   * &#x60;&#x60;&#x60;
   *  var actor = sourceActor.map(&#x27;+&#x27;);
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @method map
   * @param {Object|Function|Strin} mappingFunction
   *      Function or object with a &lt;i&gt;call method&lt;/i&gt; to use as map function.
   *      Can be string for predefined mapping functions.
   * @return {ProAct.Actor}
   *      A new ProAct.Actor instance with the &lt;i&gt;mapping&lt;/i&gt; applied.
   */
  map: P.N,

  /**
   * Creates a new ProAct.Actor instance with source &lt;i&gt;this&lt;/i&gt; and filtering
   * the passed &lt;i&gt;filtering function&lt;/i&gt;.
   * &lt;p&gt;
   *  Should be overridden with creating the right actor.
   * &lt;/p&gt;
   *
   * &#x60;&#x60;&#x60;
   *  var actor = sourceActor.filter(function (el) {
   *    return el % 2 == 0;
   *  });
   * &#x60;&#x60;&#x60;
   *
   * or
   *
   * &#x60;&#x60;&#x60;
   *  var actor = sourceActor.filter(&#x27;odd&#x27;);
   *
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @method filter
   * @param {Object} filteringFunction
   *      The filtering function or object with a call method, should return boolean.
   * @return {ProAct.Actor}
   *      A new ProAct.Actor instance with the &lt;i&gt;filtering&lt;/i&gt; applied.
   */
  filter: P.N,

  /**
   * Creates a new ProAct.Actor instance with source &lt;i&gt;this&lt;/i&gt; and accumulation
   * the passed &lt;i&gt;accumulation function&lt;/i&gt;.
   * &lt;p&gt;
   *  Should be overridden with creating the right actor.
   * &lt;/p&gt;
   *
   * &#x60;&#x60;&#x60;
   *  var actor = sourceActor.accumulate(0, function (current, el) {
   *    return current + el;
   *  });
   * &#x60;&#x60;&#x60;
   *
   * or
   *
   * &#x60;&#x60;&#x60;
   *  var actor = sourceActor.accumulate(&#x27;+&#x27;);
   * &#x60;&#x60;&#x60;
   *
   * @for ProAct.Actor
   * @instance
   * @abstract
   * @method accumulate
   * @param {Object} initVal
   *      Initial value for the accumulation. For example &#x27;0&#x27; for sum.
   * @param {Object} accumulationFunction
   *      The function to accumulate.
   * @return {ProAct.Actor}
   *      A new ProAct.Actor instance with the &lt;i&gt;accumulation&lt;/i&gt; applied.
   */
  accumulate: P.N,

  /**
   * Defers a ProAct.Actor listener.
   * &lt;p&gt;
   *  By default this means that the listener is put into active {{#crossLink &quot;ProAct.Flow&quot;}}{{/crossLink}} using it&#x27;s
   *  {{#crossLink &quot;ProAct.Flow/pushOnce:method&quot;}}{{/crossLink}} method, but it can be overridden.
   * &lt;/p&gt;
   *
   * This method determines the order of actions, triggered by the changes in the data flow.
   * The default implementation is executing only one update on this Actor per data flow change.
   * This means that if the &#x60;Actor&#x60; depends on other three Actors, and all of them get updated,
   * it is updated only once with the last update value.
   *
   * @for ProAct.Actor
   * @protected
   * @instance
   * @method defer
   * @param {Object} event
   *      The event/value to pass to the listener.
   * @param {Object} listener
   *      The listener to defer. It should be a function or object defining the &lt;i&gt;call&lt;/i&gt; method.
   * @return {ProAct.Actor}
   *      &lt;i&gt;this&lt;/i&gt;
   */
  defer: function (event, listener) {
    var queueName = (listener.queueName) ? listener.queueName : this.queueName;

    if (P.U.isFunction(listener)) {
      P.flow.pushOnce(queueName, listener, [event]);
    } else {
      P.flow.pushOnce(queueName, listener, listener.call, [event]);
    }
    return this;
  }
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
